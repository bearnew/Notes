# 浏览器的工作原理-下

## 1. Chrome 开发者工具

1. 开发者工具

- ![开发者工具](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome_dev.PNG?raw=true)

2. 网络面板

- ![网络面板](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF.PNG?raw=true)
- ![控制器](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E6%8E%A7%E5%88%B6%E5%99%A8.PNG?raw=true)

3. 下载信息

   1. `DOMContentLoaded`，这个事件发⽣后，说明⻚⾯已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML ⽂件、JavaScript ⽂件、CSS ⽂件都已经下载完成了。
   2. `Load`，说明浏览器已经加载了所有的资源（图像、样式表等）。

4. 单个资源时间线
   1. 单个资源时间线
      - ![时间线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E7%BA%BF.PNG?raw=true)
   2. `Queuing`
      - ⾸先，⻚⾯中的资源是有优先级的，⽐如 CSS、HTML、JavaScript 等都是⻚⾯中的核⼼⽂件，所以优先级最⾼；⽽图⽚、视频、⾳频这类资源就不是核⼼资源，优先级就⽐较低。通常当后者遇到前者时，就需要“让路”，进⼊待排队状态。
      - 其次，我们前⾯也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起⼀个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
      - 最后，⽹络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。
   3. `Stalled`
      - 连接过程被推迟
      - 和服务器建⽴连接的阶段，这包括了建⽴ TCP 连接所花费的时间；不过如果你使⽤了 HTTPS 协议，那么还需要⼀个额外的 SSL 握⼿时间，
   4. 第⼀字节时间（`TTFB`）时间过久
      - 服务器⽣成⻚⾯数据的时间过久
      - ⽹络的原因
      - 发送请求头时带上了多余的⽤⼾信息
      - 解决方法
        1. 去提⾼服务器的处理速度，⽐如通过增加各种缓存的技术
        2. 以使⽤ CDN 来缓存⼀些静态⽂件
        3. 去尽可能地减少⼀些不必要的 Cookie 数据信息

## 2-DOM 树：JavaScript 是如何影响 DOM 树构建的？

1. DOM
   - `DOM` 提供了对 HTML ⽂档结构化的表述。
   - 从⻚⾯的视⻆来看，`DOM` 是⽣成⻚⾯的基础数据结构。
   - 从 `JavaScript` 脚本视⻆来看，`DOM` 提供给 `JavaScript` 脚本操作的接⼝，通过这套接⼝，`JavaScript` 可以对 `DOM` 结构进⾏访问，从⽽改变⽂档的结构、样式和内容。
   - 从安全视⻆来看，`DOM` 是⼀道安全防护线，⼀些不安全的内容在 `DOM` 解析阶段就被拒之⻔外了。
2. DOM 树如何生成
   - HTML 解析器（HTMLParser）, 负责将 HTML 字节流转换为 DOM 结构。
   - HTML 解析器开始⼯作时，会默认创建了⼀个根为 document 的空 DOM 结构
   - ![字节流转 DOM](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%ACDOM.PNG?raw=true)
   - ![字节流生成的 token](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%9F%E6%88%90%E7%9A%84token.PNG?raw=true)
3. JavaScript 是如何影响 DOM ⽣成的
   - 解析到`<script>`标签时，渲染引擎判断这是⼀段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经⽣成的 DOM 结构。
   - 脚本执⾏完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直⾄⽣成最终的 DOM
   - JavaScript ⽂件的下载过程会阻塞 DOM 解析
   - Chrome 浏览器做了很多优化，其中⼀个主要的优化是预解析操作,当渲染引擎收到字节流之后，会开启⼀个预解析线程，⽤来分析 HTML ⽂件中包含的 JavaScript、CSS 等相关⽂件，解析到相关⽂件之后，预解析线程会提前下载这些⽂件。
   - 如果 JavaScript ⽂件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
   - 使⽤ async 标志的脚本⽂件⼀旦加载完成，会⽴即执⾏；
   - ⽽使⽤了 defer 标记的脚本⽂件，需要等到 DOMContentLoaded 事件之后执⾏
   - 不知道 JavaScript 是否操纵了 CSSOM 的，在执⾏ JavaScript 之前，还需要等待外部的 CSS ⽂件下载完成，并解析⽣成 CSSOM 对象之后，才能执⾏ JavaScript 脚本。

## 3.渲染流⽔线：CSS 如何影响⾸次加载时的⽩屏时间？

1. 渲染流水线
   - ![流水线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
2. `CSSOM`也具有两个作⽤，第⼀个是提供给`JavaScript`操作样式表的能⼒，第⼆个是为布局树的合成提供基础的样式信息。
3. `CSSOM`体现在 DOM 中就是`document.styleSheets`。
4. DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树
5. 复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算
6. 样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的⼏何位置，这个过程就是计算布局。
7. 通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进⾏后续的绘制操作了。
8. 等待 CSS ⽂件和 JavaScript ⽂件的加载完成，⽣成 CSSOM 和 DOM，然后合成布局树的过程，称为解析白屏。
9. 缩短白屏
   1. 通过内联 JavaScript、内联 CSS 来移除这两种类型的⽂件下载，这样获取到 HTML ⽂件之后就可以直接开始渲染流程了。
   2. 通过 webpack 等⼯具移除⼀些不必要的注释，并压缩 JavaScript ⽂件。
   3. 将⼀些不需要在解析 HTML 阶段使⽤的 JavaScript 标记上 async 或者 defer。
   4. 对于⼤的 CSS ⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的 CSS ⽂件，这样只有在特定的场景下才会加载特定的 CSS ⽂件

## 4-分层和合成机制：为什么 CSS 动画⽐ JavaScript ⾼效？

1. 显示器怎么显示图像
   1. 显示器有固定 60hz 的刷新频率，每秒更新 60 张图片
   2. 更新的图片都来自于显卡中一个叫前缓冲区的地方，将读取的图像显示到显示器上
2. 显卡
   1. 显卡的职责是合成新图像，将图像保存到后缓冲区中
   2. 图像写到后缓冲区后，系统会让后缓冲区和前缓冲区互换
   3. 渲染流水线生成的每一副图片成为一帧
3. 如何生成 1 帧图像
   1. 重排需要根据`CSSOM`和`DOM`来计算布局树，会让渲染流水线的每个过程都执行一遍
   2. 重绘没有重新布局的阶段，效率稍高，只需要绘制
   3. 合成，没有重新布局和绘制，如果使用 GPU，合成效率非常高
   4.
4. 分层和合成
   1. 为了提升每帧的渲染效率，`Chrome`引⼊了分层和合成的机制
   2. 在 Chrome 的渲染流⽔线中，分层体现在⽣成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流⽔线后续流程的基础结构。
   3. 合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线
      程执⾏的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执⾏的原因。
   4. 如果没有采⽤分层机制，从布局树直接⽣成⽬标图⽚的话，那么每次⻚⾯有很⼩的变化时，都会触发重排或者重绘机制，
5. 分块
   1. 合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块
   2. 从计算机内存上传到 GPU 内存的操作会⽐较慢
   3. Chrome ⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚，如可
      以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。
   4. ⾸次显⽰⻚⾯内容的时候，将这个低分辨率的图⽚显⽰出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显⽰的低分辨率内容
6. CSS 动画不会影响主线程，JS 会
7. 每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存。

## 5-⻚⾯性能：如何系统地优化⻚⾯？

1. 页面有 3 个阶段
   1. 加载阶段
   2. 交互阶段
   3. 关闭阶段
2. 加载阶段
   - ![加载流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/load_process_line.PNG?raw=true)
   - 影响页面加载的因素
     1. 关键资源的个数
     2. 关键资源的大小
     3. 关键资源需要多少个 RTT(Round Trip Time, 表⽰从发送端发送数据开始，到发送端收到来⾃接收端的确认，总共经历的时延)
   - 优化
     1. 内联 js css,`<script>`改成`sync`或者`defer`,通过 media 控制 CSS 是否加载
     2. 减少资源大小
     3. CDN 减少每次 RTT 时长
3. 交互阶段
   - ![交互流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
   - 优化
     1. 减少 js 执行时间，拆解函数，使用`web workers`处理耗时任务
     2. 避免强制布局（计算样式和布局都是在当前脚本执⾏过程中触发的）
     3. 避免布局抖动
     4. 合理使用 css 合成动画
     5. 避免频繁的垃圾回收，在函数中频繁创建临时对象，垃圾回收会频繁的执行，从而占用主线程

## 6-虚拟 DOM：虚拟 DOM 和实际的 DOM 有何不同？

1. 操作 DOM 会引起重排、重绘、合成，还有强制同步布局和布局抖动
2. 虚拟 DOM
   - **创建阶段**: ⾸先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟
     DOM 树创建出真实 DOM 树，真实的 DOM 树⽣成完后，再触发渲染流⽔线往屏幕输出⻚⾯。
   - **更新 DOM**： 如果数据发⽣了改变，那么就需要根据新的数据创建⼀个新的虚拟 DOM 树；然后 React ⽐较两
     个树，找出变化的地⽅，并把变化的地⽅⼀次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流⽔
     线，并⽣成新的⻚⾯。
3. 核⼼算法是 reconciliation， 在执⾏算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占⽤时间过久的问题
4. 双缓存

   - ⽽使⽤双缓存，可以让你先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存
     储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显⽰缓冲区，这样就使得整个图像的输出⾮常
     稳定。
   - 把虚拟 DOM 看成是 DOM 的⼀个 buffer，和图形显⽰⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到 DOM 上，这样就能减少⼀些不必要的更新，同时还能保证 DOM 的稳定输出。

5. MVC
   - ![mvc](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/MVC%E8%99%9A%E6%8B%9FDOM.PNG?raw=true)
   - 图中的控制器是⽤来监控 DOM 的变化，⼀旦 DOM 发⽣变化，控制器便会通知模型，让其更新数据；
   - 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发⽣了变化；
   - 视图接收到更新消息之后，会根据模型所提供的数据来⽣成新的虚拟 DOM；
   - 新的虚拟 DOM ⽣成好之后，就需要与之前的虚拟 DOM 进⾏⽐较，找出变化的节点；
   - ⽐较出变化的节点之后，React 将变化的虚拟节点应⽤到 DOM 上，这样就会触发 DOM 节点的更新；
   - DOM 节点的变化⼜会触发后续⼀系列渲染流⽔线的变化，从⽽实现⻚⾯的更新。

## 7.渐进式⽹⻚应⽤（PWA）：它究竟解决了 Web 应⽤的哪些问题？

1. 浏览器的 3 大进化路线
   1. 应用程序的 web 化
   2. web 应用移动化
   3. web 操作系统化
2. PWA
   - 是⼀套理念，渐进式增强 Web 的优势，并通过技术⼿段渐进式缩短和本地应⽤或者⼩程序的距离
   - 通过`service worker`解决离线存储问题
   - 通过`service worker`解决消息推送问题
   - 通过`manifest.json`解决一级入口问题
3. service worker
   - 在⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求
   - WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去⽹络请求资源。
   - “让其运⾏在主线程之外”就是 Service Worker 来⾃ Web Worker 的⼀个核⼼思想。
   - `Web Worker`是临时的，每次 JavaScript 脚本执⾏完成之后都会退出，执⾏结果也不能保存下来，如果下次还有同样的操作，就还得重新来⼀遍
   - `Service Worker`是运⾏在浏览器进程中的，因为浏览器进程⽣命周期是最⻓的，所以在浏览器的⽣命周期内，能够为所有的⻚⾯提供服务
   - `Service Worker`有存储功能
   - 消息推送也是基于 Service Worker 来实现的
   - `ServiceWorker`采⽤`HTTPS`协议，因为采⽤`HTTPS` 的通信数据都是经过加密的，即便拦截了数据，也⽆法破解数据内容，⽽且 HTTPS 还有校验机制，通信双⽅很容易知道数据是否被篡改
4. `manifest.json` 配置⽂件
   - 可以让开发者⾃定义桌⾯的图标、显⽰名称、启动⽅式等信息，还可以设置启动画⾯、⻚⾯主题颜⾊等信息

## 8.WebComponent：像搭积⽊⼀样构建 Web 应⽤

1. 对内⾼内聚，对外低耦合
2. CSS 的全局属性阻碍组件化，任何地方都可以读取全局的 DOM，CSSOM 和 DOM 会影响组件的内部模块化
3. `webComponent`
   1. ⾸先，使⽤ template 属性来创建模板。
      - 模板元素是不会被渲染到⻚⾯上的，也就是说 DOM 树中的 template 节点不会出现在布局树中
      - 可以使⽤ template 来⾃定义⼀些基础的元素结构，这些基础的元素结构是可以被重复使⽤的
   2. 其次，我们需要创建⼀个 GeekBang 的类。
      1. 查找模板内容；
      2. 创建影⼦ DOM；
      3. 再将模板添加到 Shadow DOM 上。
         - `shadow dom`看成是⼀个作⽤域，其内部的样式和元素是不会影响到全局的样式和元素的
   3. 使⽤ customElements.define 来⾃定义元素了
   4. 像正常使⽤ HTML 元素⼀样使⽤该元素
   5. ![shadow dom](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/shadow_dom_code.PNG?raw=true)
   6. ![shadow dom](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/shadow_dom_process.PNG?raw=true)
4. 浏览器如何实现 Shadow DOM
   1. 影⼦ DOM 中的元素对于整个⽹⻚是不可⻅的
   2. 影⼦ DOM 的 CSS 不会影响到整个⽹⻚的 CSSOM，影⼦ DOM 内部的 CSS 只对内部的元素起作⽤。
   3. 浏览器为了实现影⼦ DOM 的特性，在代码内部做了⼤量的条件判断，当通过 DOM 接⼝去查找元素时，渲染引擎会去判断 geek-bang 属性下⾯的 shadow-root 元素是否是影⼦ DOM，如果是影⼦ DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就⽆法直接查询到影⼦ DOM 的内部元素了
   4. 在影⼦ DOM 内部元素的节点选择 CSS 样式的时候，会直接使⽤影⼦ DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影⼦ DOM 内部定义的样式

## 9.HTTP1 性能优化

1. HTTP1.0 引入的特性
   - 对多文件提供良好的支持
   - 引入状态码
   - HTTP/1.0 中引⼊了请求头和响应头
   - 提供`Cache`机制
   - 用户代理
2. HTTP1.1 引入的特性
   1. 持久连接
      - 改进持久连接，一个 TCP 连接上可以传输多个 HTTP 请求，只要连接未断开，TCP 连接会一直保持
      - 持久连接在 HTTP/1.1 中是默认开启，可以在 HTTP 请求头中加上 Connection: close 关闭
      - ⽬前浏览器中对于同⼀个域名，默认允许同时建⽴ 6 个 TCP 持久连接。
   2. HTTP 管线化
      - 持久连接虽然能减少 TCP 的建⽴和断开次数，但是它需要等待前⾯的请求返回之后，才能进⾏下⼀次请求
      - TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后⾯的所有请求，这就是著名的队头阻塞的问题
      - 管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。
   3. 提供虚拟主机的⽀持
      - 在 HTTP/1.0 中，每个域名绑定了⼀个唯⼀的 IP 地址，因此⼀个服务器只能⽀持⼀个域名。
      - 着虚拟主机技术的发展，需要实现在⼀台物理主机上绑定多个虚拟主机，每个虚拟主机都有⾃⼰的单独的域名，这些单独的域名都公⽤同⼀个 IP 地址。
      - 因此，HTTP/1.1 的请求头中增加了 Host 字段，⽤来表⽰当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。
   4. 对动态⽣成的内容提供了完美⽀持
      - 在设计 HTTP/1.0 时，需要在响应头中设置完整的数据⼤⼩，如 Content-Length: 901，这样浏览器就可以根据设置的数据⼤⼩来接收数据。
      - HTTP/1.1 通过引⼊ Chunk transfer 机制来解决这个问题，服务器会将数据分割成若⼲个任意⼤⼩的数据块，每个数据块发送时会附上上个数据块的⻓度，最后使⽤⼀个零⻓度的块作为发送数据完成的标志。这样就提供了对动态内容的⽀持。
   5. 客⼾端 Cookie、安全机制

## 10.HTTP2 如何提升网络速度

1. 带宽
   - 带宽是指每秒最⼤能发送或者接收的字节数
   - 每秒能发送的最⼤字节数称为上⾏带宽
   - 每秒能够接收的最⼤字节数称为下⾏带宽
   - 我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，⽽采⽤ HTTP/1.1 时，也许在加载⻚⾯资源时最⼤只能使⽤到 2.5M/S，很难将 12.5M 全部⽤满。
2. HTTP1 对宽带利用率不理想的原因
   1. TCP 慢启动
      - 刚开始 TCP 协议会采⽤⼀个⾮常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到⼀个理想状态，我们把这个过程称为慢启动
      - 慢启动是 TCP 为了减少⽹络拥塞的⼀种策略
   2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
      - 无法对关键资源进行优先下载
   3. HTTP1.1 队头阻塞
      - 在 HTTP/1.1 中使⽤持久连接时，虽然能公⽤⼀个 TCP 管道，但是在⼀个管道中同⼀时刻只能处理⼀个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态
3. HTTP/2 的多路复⽤
   - HTTP/2 的思路就是⼀个域名只使⽤⼀个 TCP ⻓连接来传输数据，这样整个⻚⾯资源的下载过程只需要⼀次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题
   - 队头阻塞的问题，等待请求完成后才能去请求下⼀个资源，这种⽅式⽆疑是最慢的，所以 HTTP/2 需要实现资源的并⾏请求，也就是任何时候都可以将请求发送给服务器，⽽并不需要等待其他请求
     的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
   - ⼀个域名只使⽤⼀个 TCP ⻓连接和消除队头阻塞问题
4. HTTP/2 多路复⽤的实现
   1. ⾸先，浏览器准备好请求数据，包括了请求⾏、请求头等信息，如果是 POST ⽅法，那么还要有请求体。
   2. 这些数据经过⼆进制分帧层处理之后，会被转换为⼀个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
   3. 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为⼀条完整的请求信息。
   4. 然后服务器处理该条请求，并将处理的响应⾏、响应头和响应体分别发送⾄⼆进制分帧层。
   5. 同样，⼆进制分帧层会将这些响应数据转换为⼀个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
   6. 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求
   7. 通过引⼊⼆进制分帧层，就实现了 HTTP 的多路复⽤技术。
5. HTTP/2 的其他特性
   1. 可以设置请求的优先级
      - HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级⾼的请求。
      - 协议大体的优先级: HTML > CSS > Blocking Script > Font >= Image >= Async Script。
   2. 服务器推送
      - HTTP/2 还可以直接将数据提前推送到浏览器
      - 在接收到 HTML 请求之后，附带将要使⽤的 CSS ⽂件和 JavaScript ⽂件⼀并发送给浏览器，这样当浏览器解析完 HTML ⽂件之后，就能直接拿到需要的 CSS ⽂件和 JavaScript ⽂件
      - 在请求头 X-Push-Url 设置需要推送的资源
      - 推送由服务器推送，无法用到缓存，时延更高，除非主页面请求足够小，Push 才能看到效果
   3. 头部压缩

## 11.HTTP3 甩掉 TCP、TLS 的包袱，构建⾼效⽹络

1. HTTP2 的缺点
   1. TCP 连接是⼀个按照顺序传输数据的管道，管道中的任意⼀个数据丢失了，那之后的数据都需要等待该数据的重新传输
   2. 系统达到了 2%的丢包率时，HTTP/1.1 的传输效率反⽽⽐ HTTP/2 表现得更好
   3. TCP 的握⼿过程也是影响传输效率的⼀个重要因素。TCP 建立连接太慢
   4. 3 次握手需要 1.5 个 RTT, TLS 连接需要 1-2 个 RTT，在传输数据之前，我们需要花掉 3〜4 个 RTT
2. HTTP3
   1. HTTP/3 选择了⼀个折中的⽅法⸺UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议
   2. QUIC 协议特点
      1. 实现了类似 TCP 的流量控制、传输可靠性的功能
         - 虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了⼀层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他⼀些 TCP 中存在的特性。
      2. 集成了 TLS 加密功能。
         - QUIC 使⽤的是 TLS1.3， 减少了握⼿所花费的 RTT 个数
      3. 实现了 HTTP/2 中的多路复⽤功能
         - 和 TCP 不同，QUIC 实现了在同⼀物理连接上可以有多个独⽴的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。
      4. 实现了快速握⼿功能
         - 由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使⽤ 0-RTT 或者 1-RTT 来建⽴连接，这意味着 QUIC 可以⽤最快的速度来发送和接收数据，这样可以⼤⼤提升⾸次打开⻚⾯的速度。
   3. 服务器和浏览器端都没有对 HTTP/3 提供⽐较完整的⽀持
   4. 部署 HTTP/3 也存在着⾮常⼤的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度
   5. 使⽤ QUIC 协议时，⼤约有 3%〜7%的丢包率

## 12-同源策略：为什么 XMLHttpRequest 不能跨域请求资源？

1. 如果 web 没有安全策略
   1. 恶意站点修改银⾏站点的 DOM、CSSOM 等信息
   2. 恶意站点在银⾏站点内部插⼊ JavaScript 脚本
   3. 劫持⽤⼾登录的⽤⼾名和密码
   4. 读取银⾏站点的 Cookie、IndexDB 等数据；
   5. 将这些信息上传⾄⾃⼰的服务器，伪造⼀些转账请求
2. 同源策略
   1. 协议、域名和端⼝都相同，我们就称这两个 URL 同源
   2. 同源策略主要表现在 DOM、Web 数据和⽹络这三个层⾯
   3. 第⼀个，DOM 层⾯。同源策略限制了来⾃不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
   4. 第⼆个，数据层。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
   5. 第三个，⽹络层⾯。同源策略限制了通过 XMLHttpRequest 等⽅式将站点的数据发送给不同源的站点
3. 浏览器时支持外部引用文件的
   1. 内容安全策略(CSP)是一种 web 应用技术用于帮助缓解大部分类型的内容注入攻击，包括 XSS 攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。
   2. 如何开启`CSP`
      1. 通过 <meta> 标签来开启 CSP 的配置; <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*;">
      2. 通过返回 `Content-Security-Policy` 这个 `HTTP Header` 即可，这个 `Header` 对应的值就是我们 `web` 内容来源的规则;
4. 跨域资源共享（CORS），使⽤该机制可以进⾏跨域访问控制，从⽽使跨域数据传输得以安全进⾏。
5. 浏览器中⼜引⼊了跨⽂档消息机制，可以通过 `window.postMessage` 的 `JavaScript` 接⼝来和不同源的 DOM 进⾏通信。

```js
//弹出一个新窗口
var domain = "http://scriptandstyle.com";
var myPopup = window.open(
  domain + "/windowPostMessageListener.html",
  "myWindow"
);

//周期性的发送消息
setInterval(function () {
  var message = "Hello!  The time is: " + new Date().getTime();
  console.log("blog.local:  sending message:  " + message);
  //send the message and target URI
  myPopup.postMessage(message, domain);
}, 6000);

//监听消息反馈
window.addEventListener(
  "message",
  function (event) {
    if (event.origin !== "http://scriptandstyle.com") return;
    console.log("received response:  ", event.data);
  },
  false
);
```

## 13-跨站脚本攻击 XSS(Cross Site Scripting)

1. ⻚⾯被注⼊了恶意`JavaScript`脚本，恶意脚本都能做哪些事情。
   1. 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息, 后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器
   2. 监听⽤⼾⾏为。恶意 `JavaScript` 可以使⽤`“addEventListener”`接⼝来监听键盘事件，⽐如可以获取⽤⼾输⼊的信⽤卡等信息，将其发送到恶意服务器
   3. 可以通过修改 DOM 伪造假的登录窗⼝，⽤来欺骗⽤⼾输⼊⽤⼾名和密码等信息
   4. 还可以在⻚⾯内⽣成浮窗⼴告，这些⼴告会严重地影响⽤⼾体验。
2. 恶意脚本是怎么注⼊的
   1. 存储型 XSS 攻击
      1. ⾸先⿊客利⽤站点漏洞将⼀段恶意 JavaScript 代码提交到⽹站的数据库中；
      2. 然后⽤⼾向⽹站请求包含了恶意 JavaScript 脚本的⻚⾯；
      3. 当⽤⼾浏览该⻚⾯的时候，恶意脚本就会将⽤⼾的 Cookie 信息等数据上传到服务器。
      4. 喜马拉雅案例
         1. 将专辑名称设置为⼀段 JavaScript 并提交
         2. 喜⻢拉雅的服务器会保存该段 JavaScript 代码到数据库中
         3. ⽤⼾打开⿊客设置的专辑时，这段代码就会在⽤⼾的⻚⾯⾥执⾏，这样就可以获取⽤⼾的 Cookie 等数据信息
         4. ⿊客拿到了⽤⼾ Cookie 信息之后，就可以利⽤ Cookie 信息在其他机器上登录该⽤⼾的账号进行恶意操作
   2. 反射型 XSS 攻击
      1. 恶意 JavaScript 脚本属于⽤⼾发送给⽹站请求中的⼀部分，随后⽹站⼜把恶意 JavaScript 脚本返回给⽤⼾。
      2. 黑客通过 QQ 群或者邮箱向用户发送一些恶意链接`http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>`
      3. 用户点击链接，服务器会将链接的参数返回给用户的 html 中
   3. 基于 DOM 的 XSS 攻击
      1. ⿊客通过各种⼿段将恶意脚本注⼊⽤⼾的⻚⾯中，⽐如通过⽹络劫持在⻚⾯传输过程中修改 HTML ⻚⾯的内容
      2. 有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的
      3. 在 Web 资源传输过程或者在⽤⼾使⽤⻚⾯的过程中修改 Web ⻚⾯的数据
3. 阻⽌ XSS 攻击
   1. 服务器对输⼊脚本进⾏过滤或转码
      - 过滤
      ```js
      // 过滤script
      input: <script>alert('你被xss攻击了')</script>;
      // 过滤后
      output: "";
      ```
      - 服务器还可以对这些内容进⾏转码
   2. 充分利⽤ CSP
      1. 限制加载其他域下的资源⽂件，这样即使⿊客插⼊了⼀个 JavaScript ⽂件，这个 JavaScript ⽂件也是⽆法被加载的；
      2. 禁⽌向第三⽅域提交数据，这样⽤⼾数据也不会外泄；
      3. 禁⽌执⾏内联脚本和未授权的脚本；
      4. 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。
   3. 使⽤ HttpOnly 属性
      - 使⽤ HttpOnly 标记的 Cookie 只能使⽤在 HTTP 请求过程中，所以⽆法通过 JavaScript 来读取这段 Cookie。

## 14-CSRF(Cross-site request forgery 跨站请求伪造) 攻击：陌⽣链接不要随便点

1. CSRF 攻击
   - 利用用户的登录态，通过第三方的站点做一些坏事
2. CSRF 攻击的方式

   1. 自动发起 GET 请求

   ```html
   <!DOCTYPE html>
   <html>
     <body>
       <h1>⿊客的站点：CSRF攻击演⽰</h1>
       <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100" />
     </body>
   </html>
   ```

   2. 自动发起 POST 请求

   ```html
   <!-- 表单自动提交 -->
   <!DOCTYPE html>
   <html>
     <body>
       <h1>⿊客的站点：CSRF攻击演⽰</h1>
       <form
         id="hacker-form"
         action="https://time.geekbang.org/sendcoin"
         method="POST"
       >
         <input type="hidden" name="user" value="hacker" />
         <input type="hidden" name="number" value="100" />
       </form>
       <script>
         document.getElementById("hacker-form").submit();
       </script>
     </body>
   </html>
   ```

   3. 引诱⽤⼾点击链接

   ```html
   <div>
     <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg />
     <a
       href="https://time.geekbang.org/sendcoin?user=hacker&number=100"
       taget="_blank"
     >
       点击下载美⼥照⽚
     </a>
   </div>
   ```

3. 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注⼊⽤⼾的⻚⾯，仅仅是利⽤服务器的漏洞和⽤⼾的登录状态来实施攻击。
4. 防⽌ CSRF 攻击
   1. 利⽤好 Cookie 的 SameSite 属性
      - `SameSite: Strict`, 浏览器会完全禁⽌第三⽅ Cookie
      - `SameSite: Lax`, 如果在第三⽅站点中使⽤ Post ⽅法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
      - `SameSite: None`, 在任何情况下都会发送 Cookie 数据
   2. 验证请求的来源站点
      - 通过`Refere`和`Origin`判断转账的来源站点
   3. CSRF Token
      - 在浏览器向服务器发起请求时，服务器⽣成⼀个 CSRF Token。
      - CSRF Token 其实就是服务器⽣成的字符串，然后将该字符串植⼊到返回的⻚⾯中
      - 在浏览器端如果要发起转账的请求，那么需要带上⻚⾯中的 CSRF Token
      - 后服务器会验证该 Token 是否合法
      - 从第三⽅站点发出的请求，那么将⽆法获取到 CSRF Token 的值
      ```html
      <!DOCTYPE html>
      <html>
        <body>
          <form action="https://time.geekbang.org/sendcoin" method="POST">
            <input
              type="hidden"
              name="csrf-token"
              value="nc98P987bcpncYhoadjoiydc9ajDlcn"
            />
            <input type="text" name="user" />
            <input type="text" name="number" />
            <input type="submit" />
          </form>
        </body>
      </html>
      ```

## 15-安全沙箱：⻚⾯和系统之间的隔离墙

1. 单进程架构的浏览器是不稳定的，浏览器进程中的任意⼀个功能出现异常都有可能影响到整个浏览器，如⻚⾯卡死、浏览器崩溃等。
2. ⿊客就有可能通过恶意的⻚⾯向浏览器中注⼊恶意程序，其中最常⻅的攻击⽅式是利⽤缓冲区溢出
3. 通过浏览器漏洞进⾏的攻击是可以⼊侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在⽤⼾的操作系统上悄悄地安装恶意软件、监听⽤⼾键盘输⼊信息以及读取⽤⼾
   硬盘上的⽂件内容。
4. 浏览器被划分为浏览器内核和渲染内核两个核⼼模块，其中浏览器内核是由⽹络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。
5. 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。
6. 浏览器进程的功能
   |渲染进程|浏览器内核|
   |:----|:-----|
   |html 解析|Cookie 存储|
   |CSS 解析|Cache 存储|
   |图片解码|网络请求|
   |JS 执行|文件读取|
   |布局|下载管理|
   |绘制|SSL/TSL|
   |XML 解析|浏览器窗口管理|
7. 浏览器的持久存储、⽹络访问和⽤⼾交互都不是在渲染进程内直接使用，在浏览器内核中实现
8. 站点隔离
   - 标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同⼀站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。
   - 实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它⽆法继续访问其他 iframe 进程的内容，因此也就⽆法攻击其他站点了。
9.
