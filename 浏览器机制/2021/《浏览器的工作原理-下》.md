# 浏览器的工作原理-下

## 1. Chrome 开发者工具

1. 开发者工具

- ![开发者工具](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome_dev.PNG?raw=true)

2. 网络面板

- ![网络面板](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF.PNG?raw=true)
- ![控制器](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E6%8E%A7%E5%88%B6%E5%99%A8.PNG?raw=true)

3. 下载信息

   1. `DOMContentLoaded`，这个事件发⽣后，说明⻚⾯已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML ⽂件、JavaScript ⽂件、CSS ⽂件都已经下载完成了。
   2. `Load`，说明浏览器已经加载了所有的资源（图像、样式表等）。

4. 单个资源时间线
   1. 单个资源时间线
      - ![时间线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E7%BA%BF.PNG?raw=true)
   2. `Queuing`
      - ⾸先，⻚⾯中的资源是有优先级的，⽐如 CSS、HTML、JavaScript 等都是⻚⾯中的核⼼⽂件，所以优先级最⾼；⽽图⽚、视频、⾳频这类资源就不是核⼼资源，优先级就⽐较低。通常当后者遇到前者时，就需要“让路”，进⼊待排队状态。
      - 其次，我们前⾯也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起⼀个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
      - 最后，⽹络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。
   3. `Stalled`
      - 连接过程被推迟
      - 和服务器建⽴连接的阶段，这包括了建⽴ TCP 连接所花费的时间；不过如果你使⽤了 HTTPS 协议，那么还需要⼀个额外的 SSL 握⼿时间，
   4. 第⼀字节时间（`TTFB`）时间过久
      - 服务器⽣成⻚⾯数据的时间过久
      - ⽹络的原因
      - 发送请求头时带上了多余的⽤⼾信息
      - 解决方法
        1. 去提⾼服务器的处理速度，⽐如通过增加各种缓存的技术
        2. 以使⽤ CDN 来缓存⼀些静态⽂件
        3. 去尽可能地减少⼀些不必要的 Cookie 数据信息

## 2-DOM 树：JavaScript 是如何影响 DOM 树构建的？

1. DOM
   - `DOM` 提供了对 HTML ⽂档结构化的表述。
   - 从⻚⾯的视⻆来看，`DOM` 是⽣成⻚⾯的基础数据结构。
   - 从 `JavaScript` 脚本视⻆来看，`DOM` 提供给 `JavaScript` 脚本操作的接⼝，通过这套接⼝，`JavaScript` 可以对 `DOM` 结构进⾏访问，从⽽改变⽂档的结构、样式和内容。
   - 从安全视⻆来看，`DOM` 是⼀道安全防护线，⼀些不安全的内容在 `DOM` 解析阶段就被拒之⻔外了。
2. DOM 树如何生成
   - HTML 解析器（HTMLParser）, 负责将 HTML 字节流转换为 DOM 结构。
   - HTML 解析器开始⼯作时，会默认创建了⼀个根为 document 的空 DOM 结构
   - ![字节流转 DOM](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%ACDOM.PNG?raw=true)
   - ![字节流生成的 token](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%9F%E6%88%90%E7%9A%84token.PNG?raw=true)
3. JavaScript 是如何影响 DOM ⽣成的
   - 解析到`<script>`标签时，渲染引擎判断这是⼀段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经⽣成的 DOM 结构。
   - 脚本执⾏完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直⾄⽣成最终的 DOM
   - JavaScript ⽂件的下载过程会阻塞 DOM 解析
   - Chrome 浏览器做了很多优化，其中⼀个主要的优化是预解析操作,当渲染引擎收到字节流之后，会开启⼀个预解析线程，⽤来分析 HTML ⽂件中包含的 JavaScript、CSS 等相关⽂件，解析到相关⽂件之后，预解析线程会提前下载这些⽂件。
   - 如果 JavaScript ⽂件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
   - 使⽤ async 标志的脚本⽂件⼀旦加载完成，会⽴即执⾏；
   - ⽽使⽤了 defer 标记的脚本⽂件，需要等到 DOMContentLoaded 事件之后执⾏
   - 不知道 JavaScript 是否操纵了 CSSOM 的，在执⾏ JavaScript 之前，还需要等待外部的 CSS ⽂件下载完成，并解析⽣成 CSSOM 对象之后，才能执⾏ JavaScript 脚本。

## 3.渲染流⽔线：CSS 如何影响⾸次加载时的⽩屏时间？

1. 渲染流水线
   - ![流水线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
2. `CSSOM`也具有两个作⽤，第⼀个是提供给`JavaScript`操作样式表的能⼒，第⼆个是为布局树的合成提供基础的样式信息。
3. `CSSOM`体现在 DOM 中就是`document.styleSheets`。
4. DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树
5. 复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算
6. 样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的⼏何位置，这个过程就是计算布局。
7. 通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进⾏后续的绘制操作了。
8. 等待 CSS ⽂件和 JavaScript ⽂件的加载完成，⽣成 CSSOM 和 DOM，然后合成布局树的过程，称为解析白屏。
9. 缩短白屏
   1. 通过内联 JavaScript、内联 CSS 来移除这两种类型的⽂件下载，这样获取到 HTML ⽂件之后就可以直接开始渲染流程了。
   2. 通过 webpack 等⼯具移除⼀些不必要的注释，并压缩 JavaScript ⽂件。
   3. 将⼀些不需要在解析 HTML 阶段使⽤的 JavaScript 标记上 async 或者 defer。
   4. 对于⼤的 CSS ⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的 CSS ⽂件，这样只有在特定的场景下才会加载特定的 CSS ⽂件

## 4-分层和合成机制：为什么 CSS 动画⽐ JavaScript ⾼效？

1. 显示器怎么显示图像
   1. 显示器有固定 60hz 的刷新频率，每秒更新 60 张图片
   2. 更新的图片都来自于显卡中一个叫前缓冲区的地方，将读取的图像显示到显示器上
2. 显卡
   1. 显卡的职责是合成新图像，将图像保存到后缓冲区中
   2. 图像写到后缓冲区后，系统会让后缓冲区和前缓冲区互换
   3. 渲染流水线生成的每一副图片成为一帧
3. 如何生成 1 帧图像
   1. 重排需要根据`CSSOM`和`DOM`来计算布局树，会让渲染流水线的每个过程都执行一遍
   2. 重绘没有重新布局的阶段，效率稍高，只需要绘制
   3. 合成，没有重新布局和绘制，如果使用 GPU，合成效率非常高
   4.
4. 分层和合成
   1. 为了提升每帧的渲染效率，`Chrome`引⼊了分层和合成的机制
   2. 在 Chrome 的渲染流⽔线中，分层体现在⽣成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流⽔线后续流程的基础结构。
   3. 合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线
      程执⾏的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执⾏的原因。
   4. 如果没有采⽤分层机制，从布局树直接⽣成⽬标图⽚的话，那么每次⻚⾯有很⼩的变化时，都会触发重排或者重绘机制，
5. 分块
   1. 合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块
   2. 从计算机内存上传到 GPU 内存的操作会⽐较慢
   3. Chrome ⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚，如可
      以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。
   4. ⾸次显⽰⻚⾯内容的时候，将这个低分辨率的图⽚显⽰出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显⽰的低分辨率内容
6. CSS 动画不会影响主线程，JS 会
7. 每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存。

## 5-⻚⾯性能：如何系统地优化⻚⾯？

1. 页面有 3 个阶段
   1. 加载阶段
   2. 交互阶段
   3. 关闭阶段
2. 加载阶段
   - ![加载流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/load_process_line.PNG?raw=true)
   - 影响页面加载的因素
     1. 关键资源的个数
     2. 关键资源的大小
     3. 关键资源需要多少个 RTT(Round Trip Time, 表⽰从发送端发送数据开始，到发送端收到来⾃接收端的确认，总共经历的时延)
   - 优化
     1. 内联 js css,`<script>`改成`sync`或者`defer`,通过 media 控制 CSS 是否加载
     2. 减少资源大小
     3. CDN 减少每次 RTT 时长
3. 交互阶段
   - ![交互流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
   - 优化
     1. 减少 js 执行时间，拆解函数，使用`web workers`处理耗时任务
     2. 避免强制布局（计算样式和布局都是在当前脚本执⾏过程中触发的）
     3. 避免布局抖动
     4. 合理使用 css 合成动画
     5. 避免频繁的垃圾回收，在函数中频繁创建临时对象，垃圾回收会频繁的执行，从而占用主线程

## 6-虚拟 DOM：虚拟 DOM 和实际的 DOM 有何不同？

1. 操作 DOM 会引起重排、重绘、合成，还有强制同步布局和布局抖动
2. 虚拟 DOM
   - **创建阶段**: ⾸先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟
     DOM 树创建出真实 DOM 树，真实的 DOM 树⽣成完后，再触发渲染流⽔线往屏幕输出⻚⾯。
   - **更新 DOM**： 如果数据发⽣了改变，那么就需要根据新的数据创建⼀个新的虚拟 DOM 树；然后 React ⽐较两
     个树，找出变化的地⽅，并把变化的地⽅⼀次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流⽔
     线，并⽣成新的⻚⾯。
3. 核⼼算法是 reconciliation， 在执⾏算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占⽤时间过久的问题
4. 双缓存

   - ⽽使⽤双缓存，可以让你先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存
     储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显⽰缓冲区，这样就使得整个图像的输出⾮常
     稳定。
   - 把虚拟 DOM 看成是 DOM 的⼀个 buffer，和图形显⽰⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到 DOM 上，这样就能减少⼀些不必要的更新，同时还能保证 DOM 的稳定输出。

5. MVC
   - ![mvc](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/MVC%E8%99%9A%E6%8B%9FDOM.PNG?raw=true)
   - 图中的控制器是⽤来监控 DOM 的变化，⼀旦 DOM 发⽣变化，控制器便会通知模型，让其更新数据；
   - 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发⽣了变化；
   - 视图接收到更新消息之后，会根据模型所提供的数据来⽣成新的虚拟 DOM；
   - 新的虚拟 DOM ⽣成好之后，就需要与之前的虚拟 DOM 进⾏⽐较，找出变化的节点；
   - ⽐较出变化的节点之后，React 将变化的虚拟节点应⽤到 DOM 上，这样就会触发 DOM 节点的更新；
   - DOM 节点的变化⼜会触发后续⼀系列渲染流⽔线的变化，从⽽实现⻚⾯的更新。

## 7.渐进式⽹⻚应⽤（PWA）：它究竟解决了 Web 应⽤的哪些问题？

1. 浏览器的 3 大进化路线
   1. 应用程序的 web 化
   2. web 应用移动化
   3. web 操作系统化
2. PWA
   - 是⼀套理念，渐进式增强 Web 的优势，并通过技术⼿段渐进式缩短和本地应⽤或者⼩程序的距离
   - 通过`service worker`解决离线存储问题
   - 通过`service worker`解决消息推送问题
   - 通过`manifest.json`解决一级入口问题
3. service worker
   - 在⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求
   - WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去⽹络请求资源。
   - “让其运⾏在主线程之外”就是 Service Worker 来⾃ Web Worker 的⼀个核⼼思想。
   - `Web Worker`是临时的，每次 JavaScript 脚本执⾏完成之后都会退出，执⾏结果也不能保存下来，如果下次还有同样的操作，就还得重新来⼀遍
   - `Service Worker`是运⾏在浏览器进程中的，因为浏览器进程⽣命周期是最⻓的，所以在浏览器的⽣命周期内，能够为所有的⻚⾯提供服务
   - `Service Worker`有存储功能
   - 消息推送也是基于 Service Worker 来实现的
   - `ServiceWorker`采⽤`HTTPS`协议，因为采⽤`HTTPS` 的通信数据都是经过加密的，即便拦截了数据，也⽆法破解数据内容，⽽且 HTTPS 还有校验机制，通信双⽅很容易知道数据是否被篡改
4. `manifest.json` 配置⽂件
   - 可以让开发者⾃定义桌⾯的图标、显⽰名称、启动⽅式等信息，还可以设置启动画⾯、⻚⾯主题颜⾊等信息

## 8.WebComponent：像搭积⽊⼀样构建 Web 应⽤

1. 对内⾼内聚，对外低耦合
2. CSS 的全局属性阻碍组件化，任何地方都可以读取全局的 DOM，CSSOM 和 DOM 会影响组件的内部模块化
3. `webComponent`
   1. ⾸先，使⽤ template 属性来创建模板。
      - 模板元素是不会被渲染到⻚⾯上的，也就是说 DOM 树中的 template 节点不会出现在布局树中
      - 可以使⽤ template 来⾃定义⼀些基础的元素结构，这些基础的元素结构是可以被重复使⽤的
   2. 其次，我们需要创建⼀个 GeekBang 的类。
      1. 查找模板内容；
      2. 创建影⼦ DOM；
      3. 再将模板添加到 Shadow DOM 上。
         - `shadow dom`看成是⼀个作⽤域，其内部的样式和元素是不会影响到全局的样式和元素的
   3. 使⽤ customElements.define 来⾃定义元素了
   4. 像正常使⽤ HTML 元素⼀样使⽤该元素
   5. ![shadow dom](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/shadow_dom_code.PNG?raw=true)
   6. ![shadow dom](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/shadow_dom_process.PNG?raw=true)
4. 浏览器如何实现 Shadow DOM
   1. 影⼦ DOM 中的元素对于整个⽹⻚是不可⻅的
   2. 影⼦ DOM 的 CSS 不会影响到整个⽹⻚的 CSSOM，影⼦ DOM 内部的 CSS 只对内部的元素起作⽤。
   3. 浏览器为了实现影⼦ DOM 的特性，在代码内部做了⼤量的条件判断，当通过 DOM 接⼝去查找元素时，渲染引擎会去判断 geek-bang 属性下⾯的 shadow-root 元素是否是影⼦ DOM，如果是影⼦ DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就⽆法直接查询到影⼦ DOM 的内部元素了
   4. 在影⼦ DOM 内部元素的节点选择 CSS 样式的时候，会直接使⽤影⼦ DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影⼦ DOM 内部定义的样式

## 9.HTTP 性能优化

1. HTTP1.0 引入的特性
   - 对多文件提供良好的支持
   - 引入状态码
   - HTTP/1.0 中引⼊了请求头和响应头
   - 提供`Cache`机制
   - 用户代理
2. HTTP1.1 引入的特性
   1. 持久连接
      - 改进持久连接，一个 TCP 连接上可以传输多个 HTTP 请求，只要连接未断开，TCP 连接会一直保持
      - 持久连接在 HTTP/1.1 中是默认开启，可以在 HTTP 请求头中加上 Connection: close 关闭
      - ⽬前浏览器中对于同⼀个域名，默认允许同时建⽴ 6 个 TCP 持久连接。
   2. HTTP 管线化
      - 持久连接虽然能减少 TCP 的建⽴和断开次数，但是它需要等待前⾯的请求返回之后，才能进⾏下⼀次请求
      - TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后⾯的所有请求，这就是著名的队头阻塞的问题
      - 管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。
   3. 提供虚拟主机的⽀持
      - 在 HTTP/1.0 中，每个域名绑定了⼀个唯⼀的 IP 地址，因此⼀个服务器只能⽀持⼀个域名。
      - 着虚拟主机技术的发展，需要实现在⼀台物理主机上绑定多个虚拟主机，每个虚拟主机都有⾃⼰的单独的域名，这些单独的域名都公⽤同⼀个 IP 地址。
      - 因此，HTTP/1.1 的请求头中增加了 Host 字段，⽤来表⽰当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。
   4. 对动态⽣成的内容提供了完美⽀持
      - 在设计 HTTP/1.0 时，需要在响应头中设置完整的数据⼤⼩，如 Content-Length: 901，这样浏览器就可以根据设置的数据⼤⼩来接收数据。
      - HTTP/1.1 通过引⼊ Chunk transfer 机制来解决这个问题，服务器会将数据分割成若⼲个任意⼤⼩的数据块，每个数据块发送时会附上上个数据块的⻓度，最后使⽤⼀个零⻓度的块作为发送数据完成的标志。这样就提供了对动态内容的⽀持。
   5. 客⼾端 Cookie、安全机制
