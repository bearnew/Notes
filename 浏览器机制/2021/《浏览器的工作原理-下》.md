# 浏览器的工作原理-下

## 1. Chrome 开发者工具

1. 开发者工具

- ![开发者工具](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome_dev.PNG?raw=true)

2. 网络面板

- ![网络面板](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF.PNG?raw=true)
- ![控制器](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E6%8E%A7%E5%88%B6%E5%99%A8.PNG?raw=true)

3. 下载信息

   1. `DOMContentLoaded`，这个事件发⽣后，说明⻚⾯已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML ⽂件、JavaScript ⽂件、CSS ⽂件都已经下载完成了。
   2. `Load`，说明浏览器已经加载了所有的资源（图像、样式表等）。

4. 单个资源时间线
   1. 单个资源时间线
      - ![时间线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E7%BA%BF.PNG?raw=true)
   2. `Queuing`
      - ⾸先，⻚⾯中的资源是有优先级的，⽐如 CSS、HTML、JavaScript 等都是⻚⾯中的核⼼⽂件，所以优先级最⾼；⽽图⽚、视频、⾳频这类资源就不是核⼼资源，优先级就⽐较低。通常当后者遇到前者时，就需要“让路”，进⼊待排队状态。
      - 其次，我们前⾯也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起⼀个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
      - 最后，⽹络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。
   3. `Stalled`
      - 连接过程被推迟
      - 和服务器建⽴连接的阶段，这包括了建⽴ TCP 连接所花费的时间；不过如果你使⽤了 HTTPS 协议，那么还需要⼀个额外的 SSL 握⼿时间，
   4. 第⼀字节时间（`TTFB`）时间过久
      - 服务器⽣成⻚⾯数据的时间过久
      - ⽹络的原因
      - 发送请求头时带上了多余的⽤⼾信息
      - 解决方法
        1. 去提⾼服务器的处理速度，⽐如通过增加各种缓存的技术
        2. 以使⽤ CDN 来缓存⼀些静态⽂件
        3. 去尽可能地减少⼀些不必要的 Cookie 数据信息

## 2-DOM 树：JavaScript 是如何影响 DOM 树构建的？

1. DOM
   - `DOM` 提供了对 HTML ⽂档结构化的表述。
   - 从⻚⾯的视⻆来看，`DOM` 是⽣成⻚⾯的基础数据结构。
   - 从 `JavaScript` 脚本视⻆来看，`DOM` 提供给 `JavaScript` 脚本操作的接⼝，通过这套接⼝，`JavaScript` 可以对 `DOM` 结构进⾏访问，从⽽改变⽂档的结构、样式和内容。
   - 从安全视⻆来看，`DOM` 是⼀道安全防护线，⼀些不安全的内容在 `DOM` 解析阶段就被拒之⻔外了。
2. DOM 树如何生成
   - HTML 解析器（HTMLParser）, 负责将 HTML 字节流转换为 DOM 结构。
   - HTML 解析器开始⼯作时，会默认创建了⼀个根为 document 的空 DOM 结构
   - ![字节流转 DOM](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%ACDOM.PNG?raw=true)
   - ![字节流生成的 token](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%9F%E6%88%90%E7%9A%84token.PNG?raw=true)
3. JavaScript 是如何影响 DOM ⽣成的
   - 解析到`<script>`标签时，渲染引擎判断这是⼀段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经⽣成的 DOM 结构。
   - 脚本执⾏完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直⾄⽣成最终的 DOM
   - JavaScript ⽂件的下载过程会阻塞 DOM 解析
   - Chrome 浏览器做了很多优化，其中⼀个主要的优化是预解析操作,当渲染引擎收到字节流之后，会开启⼀个预解析线程，⽤来分析 HTML ⽂件中包含的 JavaScript、CSS 等相关⽂件，解析到相关⽂件之后，预解析线程会提前下载这些⽂件。
   - 如果 JavaScript ⽂件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
   - 使⽤ async 标志的脚本⽂件⼀旦加载完成，会⽴即执⾏；
   - ⽽使⽤了 defer 标记的脚本⽂件，需要等到 DOMContentLoaded 事件之后执⾏
   - 不知道 JavaScript 是否操纵了 CSSOM 的，在执⾏ JavaScript 之前，还需要等待外部的 CSS ⽂件下载完成，并解析⽣成 CSSOM 对象之后，才能执⾏ JavaScript 脚本。

## 3.渲染流⽔线：CSS 如何影响⾸次加载时的⽩屏时间？

1. 渲染流水线
   - ![流水线](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
2. `CSSOM`也具有两个作⽤，第⼀个是提供给`JavaScript`操作样式表的能⼒，第⼆个是为布局树的合成提供基础的样式信息。
3. `CSSOM`体现在 DOM 中就是`document.styleSheets`。
4. DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树
5. 复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算
6. 样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的⼏何位置，这个过程就是计算布局。
7. 通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进⾏后续的绘制操作了。
8. 等待 CSS ⽂件和 JavaScript ⽂件的加载完成，⽣成 CSSOM 和 DOM，然后合成布局树的过程，称为解析白屏。
9. 缩短白屏
   1. 通过内联 JavaScript、内联 CSS 来移除这两种类型的⽂件下载，这样获取到 HTML ⽂件之后就可以直接开始渲染流程了。
   2. 通过 webpack 等⼯具移除⼀些不必要的注释，并压缩 JavaScript ⽂件。
   3. 将⼀些不需要在解析 HTML 阶段使⽤的 JavaScript 标记上 async 或者 defer。
   4. 对于⼤的 CSS ⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的 CSS ⽂件，这样只有在特定的场景下才会加载特定的 CSS ⽂件

## 4-分层和合成机制：为什么 CSS 动画⽐ JavaScript ⾼效？

1. 显示器怎么显示图像
   1. 显示器有固定 60hz 的刷新频率，每秒更新 60 张图片
   2. 更新的图片都来自于显卡中一个叫前缓冲区的地方，将读取的图像显示到显示器上
2. 显卡
   1. 显卡的职责是合成新图像，将图像保存到后缓冲区中
   2. 图像写到后缓冲区后，系统会让后缓冲区和前缓冲区互换
   3. 渲染流水线生成的每一副图片成为一帧
3. 如何生成 1 帧图像
   1. 重排需要根据`CSSOM`和`DOM`来计算布局树，会让渲染流水线的每个过程都执行一遍
   2. 重绘没有重新布局的阶段，效率稍高，只需要绘制
   3. 合成，没有重新布局和绘制，如果使用 GPU，合成效率非常高
   4.
4. 分层和合成
   1. 为了提升每帧的渲染效率，`Chrome`引⼊了分层和合成的机制
   2. 在 Chrome 的渲染流⽔线中，分层体现在⽣成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流⽔线后续流程的基础结构。
   3. 合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线
      程执⾏的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执⾏的原因。
   4. 如果没有采⽤分层机制，从布局树直接⽣成⽬标图⽚的话，那么每次⻚⾯有很⼩的变化时，都会触发重排或者重绘机制，
5. 分块
   1. 合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块
   2. 从计算机内存上传到 GPU 内存的操作会⽐较慢
   3. Chrome ⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚，如可
      以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。
   4. ⾸次显⽰⻚⾯内容的时候，将这个低分辨率的图⽚显⽰出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显⽰的低分辨率内容
6. CSS 动画不会影响主线程，JS 会
7. 每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存。

## 5-⻚⾯性能：如何系统地优化⻚⾯？

1. 页面有 3 个阶段
   1. 加载阶段
   2. 交互阶段
   3. 关闭阶段
2. 加载阶段
   - ![加载流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/load_process_line.PNG?raw=true)
   - 影响页面加载的因素
     1. 关键资源的个数
     2. 关键资源的大小
     3. 关键资源需要多少个 RTT(Round Trip Time, 表⽰从发送端发送数据开始，到发送端收到来⾃接收端的确认，总共经历的时延)
   - 优化
     1. 内联 js css,`<script>`改成`sync`或者`defer`,通过 media 控制 CSS 是否加载
     2. 减少资源大小
     3. CDN 减少每次 RTT 时长
3. 交互阶段
   - ![交互流程](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG?raw=true)
   - 优化
     1. 减少 js 执行时间，拆解函数，使用`web workers`处理耗时任务
     2. 避免强制布局（计算样式和布局都是在当前脚本执⾏过程中触发的）
     3. 避免布局抖动
     4. 合理使用 css 合成动画
     5. 避免频繁的垃圾回收，在函数中频繁创建临时对象，垃圾回收会频繁的执行，从而占用主线程

## 6-虚拟 DOM：虚拟 DOM 和实际的 DOM 有何不同？

1. 操作 DOM 会引起重排、重绘、合成，还有强制同步布局和布局抖动
2. 虚拟 DOM
   - **创建阶段**: ⾸先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟
     DOM 树创建出真实 DOM 树，真实的 DOM 树⽣成完后，再触发渲染流⽔线往屏幕输出⻚⾯。
   - **更新 DOM**： 如果数据发⽣了改变，那么就需要根据新的数据创建⼀个新的虚拟 DOM 树；然后 React ⽐较两
     个树，找出变化的地⽅，并把变化的地⽅⼀次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流⽔
     线，并⽣成新的⻚⾯。
3. 核⼼算法是 reconciliation， 在执⾏算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占⽤时间过久的问题
4. 双缓存

   - ⽽使⽤双缓存，可以让你先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存
     储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显⽰缓冲区，这样就使得整个图像的输出⾮常
     稳定。
   - 把虚拟 DOM 看成是 DOM 的⼀个 buffer，和图形显⽰⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到 DOM 上，这样就能减少⼀些不必要的更新，同时还能保证 DOM 的稳定输出。

5. MVC
   - ![mvc](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/MVC%E8%99%9A%E6%8B%9FDOM.PNG?raw=true)
   - 图中的控制器是⽤来监控 DOM 的变化，⼀旦 DOM 发⽣变化，控制器便会通知模型，让其更新数据；
   - 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发⽣了变化；
   - 视图接收到更新消息之后，会根据模型所提供的数据来⽣成新的虚拟 DOM；
   - 新的虚拟 DOM ⽣成好之后，就需要与之前的虚拟 DOM 进⾏⽐较，找出变化的节点；
   - ⽐较出变化的节点之后，React 将变化的虚拟节点应⽤到 DOM 上，这样就会触发 DOM 节点的更新；
   - DOM 节点的变化⼜会触发后续⼀系列渲染流⽔线的变化，从⽽实现⻚⾯的更新。
