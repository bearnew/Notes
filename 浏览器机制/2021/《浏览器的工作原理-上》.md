# 浏览器的工作原理

## 1.chrome 架构

### 1.chrome 架构

1. `Chrome`,微软 Edge 以及国内的大部分主流浏览器都是基于`Chromium`二次开发而来
2. `Chrome`是`Google`的先行版，特性和`Chromium`基本一样

### 2.进程和线程

1. 1 个进程就是 1 个程序的运行实例
2. 线程是由进程来启动和管理的，进程中使用多线程并行处理能提升运行效率
3. 进程中任一线程执行出错，都会导致整个进程的的崩溃
4. 线程之间共享进程中的数据
5. 进程关闭后，操作系统会回收进程中占用的内存
6. 进行之间的内容是相互隔离的

### 3.单进程浏览器

1. 单进程浏览器是指浏览器的所有功能模块（网络、插件、js 运行环境、渲染引擎、页面等）都是运行在同一个进程里
2. **不稳定**：某个模块崩溃，整个浏览器崩溃
3. **不流畅**: 同一时刻只有一个模块可以执行
4. **不安全**: 运行某个插件，会只有这个插件操作电脑

### 4.多进程浏览器

1. 架构图

- ![JIAGOU](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/chrome_%E6%9E%B6%E6%9E%84.PNG?raw=true)

2. 进程相互独立，模块崩溃不会影响整个浏览器
3. js 阻塞了渲染进程，只会影响当前页面。内存泄漏关闭当前页面即可
4. 将插件进程和渲染进程放在安全沙箱中执行，限制他们的系统权限，保证安全性
5. 多进程浏览器会占用更高的内存

### 5.多进程浏览器进程

1. 进程

- ![进程]()

2. **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
3. **渲染进程**：核心任务是将 html,js,css 转换为用户可以与之交互的网页，排版引擎 Blink 和 js 引擎 v8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。出
   于安全考虑，渲染进程都是运⾏在沙箱模式下。
4. **GPU 进程**：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的
   效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最
   后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
5. **网络进程**：主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独
   ⽴出来，成为⼀个单独的进程。
6. **插件进程**： 主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃
   不会对浏览器和⻚⾯造成影响。

### 6.面向服务的架构

1. 每个服务在独立的进程中运行，访问服务必须通过定义好的接口，通过`IPC`来通信，从而构建一个更内聚、松藕性、易于维护和扩展的系统，更好的实现 Chrome 简单、稳定、⾼速、安全的⽬
   标
2. ![service_framework](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/next_chrome_framework.PNG?raw=true)
3.

## 2.TCP 协议

1. `FP(First Paint)`：从页面加载到首次开始绘制的时长，受网络加载速度的影响
2. `IP地址`：计算机的地址，主机 A 发送给主机 B，数据包会附带上主机 B 和主机 A 的 IP 信息，包括 IP 版本、源 IP 地址、目标 IP 地址、生存时间等、
3. `UDP`: 将数据包送达应用程序
   - 以 `IP` 通过 `IP` 地址信息把数据包发送给指定的电脑，⽽ `UDP` 通过端⼝号把数据包分发给正确的程序。
   - `UDP`可以校验数据是否正确，无重发机制，失败则丢弃
   - `UDP`不能保证数据可靠性，但传输速度却非常快
   - 大文件拆成小的数据包传输，小的数据包经过不同的路由在不同的时间到达接收端，
4. 网络通信
   - 主机 A 将数据包交给网络层
   - 传输层在数据包前面附加上 UDP 头，组成新的 UDP 包，并交给网络层
   - 网络层将 IP 头附加到数据包，组成新的 IP 数据包，交给底层
   - 底层通过物理网络将数据包传输给主机 B
   - 数据包被传送到主机 B 的网络层，主机 B 拆开数据包的 IP 头信息，将拆开的数据部分交给传输层
   - 在传输层，UDP 头被拆开，根据 UDP 提供的端口号，将数据交给上层的应用程序
   - 主机 B 的上层收到数据包
5. `TCP`
   1. `TCP`是⼀种⾯向连接的、可靠的、基于字节流的传输层通信协议。
   2. 对于数据包丢失的情况，TCP 提供重传机制；
   3. TCP 引⼊了数据包排序机制，⽤来保证把乱序的数据包组合成⼀个完整的⽂件。
   4. 和 UDP 头⼀样，TCP 头除了包含了⽬标端⼝和本机端⼝号外，还提供了⽤于排序的序列号，以便接收端通过序号来重排数据包。
   5. 传输流程
      - 建立连接：三次握手
      - 传输数据：接收端需要对每个数据包进行确认，接收端收到后会发确认数据包给发送端，接收端收到很多小的数据包，会按 TCP 头的序号进行排列，从而保证组成完整的数据
      - 断开连接：四次挥手
6.

## 3.HTTP 请求流程

1. HTTP 请求流程

- ![example](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http_request_progress.PNG?raw=true)

2. 站点第 2 次打开速度会很快
   - `DNS`缓存
   - 页面资源缓存
3. 登录态的保持
   - 服务器收到用户的请求，将用户的登陆信息加密后放到`set-cookie`中
   - 浏览器收到响应头后，将`set-cookie`中的信息放到`cookie`中
   - 浏览器再次请求时会带上`cookie`中的信息
   - 服务器查找`cookie`中的信息，判断用户的登录态

## 4.导航流程

1. 用户输入
2. URL 请求过程
   1. 浏览器进程通过进程间通信（IPC）把 URL 请求发送至网络进程
   2. 网络进程查找本地缓存，存在缓存，直接返回
   3. 无缓存，进行 DNS 解析，HTTPS 的话，需要建立 TLS 连接
   4. 用 IP 地址和服务器建立 TCP 连接，连接建立后，浏览器会构建请求行、请求头、将`cookie`附加到请求头中，发送给服务器
   5. 服务器响应
   6. 浏览器接收到响应头中包含 301 或者 302，读取响应头的 location 字段，重定向到该 URL，然后再发起新的`http/https`请求
   7. 浏览器接收到响应头是 200，会继续处理请求
   8. 浏览器根据`content-type`来决定显示响应体的内容，是下载类型，还是正常的`html`页面
      - `Content-type: text/html`: HTML 格式
      - `Content-type: application/octet-stream`: 字节流类型/下载类型
   9. chrome 每打开一个新页面，就会分配 1 个渲染进程，但是打开的页面根域名`geekbang.org`相同，新页面会复用父页面的渲染进程
   10. 浏览器发出提交请求，会和网络进程建立管道，文档数据传输完后，渲染进程会返回确认提交，浏览器收到确认提交后会更新浏览器界面状态
   11. 一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图上的加载动画

## 5.渲染流程-上

1. HTML 是由标签和文本组成的
2. CSS 是由选择器和属性组成的
3. JS 使网页动起来
4. 构建 DOM 树
   - 浏览器无法直接理解和使用`HTML`，所以需要将`HTML`转换为浏览器能够理解的结构 DOM 树
   - HTML 文件通过 HTML 解析器解析输出树状结构的`DOM`
   - `console.log(document)`可以看到完整的`dom`树结构
   - DOM 树和 HTML 内容几乎一样，但 DOM 是保存在内存中的树状结构，可以通过 js 查询或修改
   -
5. 样式计算
   - 把 css 转换成浏览器能够理解的结构
   - css 的样式来源有 3 种
     - 通过`link`引用的外部 css 文件
     - `<style>`标记内的 css
     - 元素`style`属性内嵌的 css
   - 渲染引擎接收到 css，会执行转换操作，将 css 文本转换为浏览器可以理解的结构`styleSheets`
   - 通过`console.log(document.styleSheets)`查看 css 结构
   - css 继承就是每个 DOM 节点都包含父节点的样式
   - 样式来源样式文件或者`UserAgent`样式表
   - `UserAgent`样式是由浏览器提供的一组默认样式
   - css 层叠是合并来自多个源的属性值的算法，可通过`chrome`的`Computed`子标签查看
6. 创建布局树
   1. 遍历 DOM 树的所有可见节点，并将这些节点加入到布局中
   2. 不可见的节点会被布局树忽略掉，如`head`标签下的全部内容，`display：none`的元素
7. 布局计算
   - 布局计算会把布局运算的结果重新写回到布局树中

## 6.渲染流程-下

1. 分层
   - 渲染引擎需要为特定的节点生成专用的图层，并生成一颗对应的图层树（`LayerTree`）
   - 分层是为了实现复杂的 3D 变换、页面滚动、z-index 做 z 轴排序
   - 通过`chrome`的工具栏的`layers`可查看网页的分层信息
   - 浏览器的页面会被分成很多图层，图层叠加后合成了最终的页面
   - 第一点，拥有层叠上下文属性的元素会被提升为单独的一层
   - 需要裁剪`clip`的地方也会被创建为图层
   - ![layer](https://github.com/bearnew/picture/blob/master/markdown_v2/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/layout_and_layer.PNG?raw=true)
2. 图层绘制
3. 栅格化(`raster`)操作
   1. 合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格化，是指将图块转换为位图
   2. 栅格化过程都会使⽤ GPU 来加速⽣成
4. 合成和显示
   - 将其⻚⾯内容绘制到内存中，最后再将内存显⽰在屏幕上。
5. 渲染流程总结
   1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
   2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
   3. 创建布局树，并计算元素的布局信息。
   4. 对布局树进⾏分层，并⽣成分层树。
   5. 为每个图层⽣成绘制列表，并将其提交到合成线程。
   6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图（是由称作像素（图片元素）的单个点组成的，与之对应的是矢量图，位图占用空间更大，位图需要进行复杂的处理才能转换成矢量图）。
   7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
   8. 浏览器进程根据 DrawQuad 消息⽣成⻚⾯，并显⽰到显⽰器上。
6. 重排
   - 改变元素的宽度高度等几何属性，会重排，重排需要更新完整的渲染流水线，开销最大
7. 重绘
   - 改变元素背景颜色等绘制属性，会重绘，重绘省去了布局和分层，执行效率会比重排更高一些
8. 直接合成阶段
   - 使用`transform`可以避开重绘和重排，直接执行合成动画操作，因为在非主线程上合成，不会占用主线程的资源，能大大提高绘制效率

## 7.变量提升

#### 1.执行上下文

1. 在执⾏过程中，若使⽤了未声明的变量，那么 JavaScript 执⾏会报错。
2. 在⼀个变量定义之前使⽤它，不会出错，但是该变量的值会为 undefined，⽽不是定义时的值。
3. 在⼀个函数定义之前使⽤它，不会出错，且函数能正确执⾏。

#### 2.声明和赋值

1. 在`JavaScript`代码执⾏过程中，`JavaScript`引擎把变量的声明部分和函数的声明部
   分提升到代码开头的“⾏为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的`undefined`。

#### 3.JS 的执行流程

1. 实际上变量和函数声明在代码⾥的位置是不会改变的，⽽且是在编译阶段被 JavaScript 引擎放⼊内存中。
2. ⼀段 JavaScript 代码在执⾏之前需要被 JavaScript 引擎编译，编译完成之后，才会进⼊执⾏阶段。
3. 编译阶段

```js
// 第1⾏和第2⾏，由于这两⾏代码不是声明操作，所以JavaScript引擎不会做任何处理；
// 第3⾏，由于这⾏是经过var声明的，因此JavaScript引擎将在环境对象中创建⼀个名为myname的属性，并使⽤undefined对其初始化；
// 第4⾏，JavaScript引擎发现了⼀个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建⼀个showName的属性，然后将该属性值指向堆中函数的位置。
showName();
console.log(myname);
var myname = "极客时间";
function showName() {
  console.log("函数showName被执⾏");
}
```

4. 执行阶段

```js
// 当执⾏到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引⽤，所以JavaScript引擎便开始执⾏该函数，并输出“函数showName被执⾏”结果。
// 接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。
// 接下来执⾏第3⾏，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”
showName();
console.log(myname);
var myname = "极客时间";
function showName() {
  console.log("函数showName被执⾏");
}
```

5. 相同变量或函数
   1. 编译阶段，遇到重复的函数，第 2 个会把第 1 个覆盖掉，存放在变量环境中
