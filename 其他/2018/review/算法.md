#### 一、滑动窗口

###### 1. 最小覆盖字串

> 返回 s 中涵盖 t 所有字符的最小子串

1. 滑动窗口，left 和 right
2. tFreq 存储字符 s 存在的次数，winFreq 存储窗口给内字符 s 存在的次数
3. distance 存储包含到的字符的个数
4. begin 从哪里开始
5. winFreq 中字符 s 数量小于 tFreq 中字符 s 数量，包含字符串的长度 distance++
6. distance 等于 t.length，证明包含完全
7. 替换 minLen
8. 左侧不包含子串，缩短左侧
9. 左侧包含字串，缩短左侧，distance--

```js
// 定义各种变量
const tFreq = {}; // t中每个字符串包含的次数
const winFreq = {}; // 滑动窗口中包含t中每个字符串的次数
let left = 0; // 滑动窗口左
let right = 0; // 滑动窗口右
let distance = 0; // 有效路径
let minLen = s.length + 1; // 最长
var begin = 0;
```

```js
// 遍历t存储tFreq和winFreq
for (let i = 0; i < t.length; i++) {
    const str = t[i];
    if (!tFreq[str]) {
        tFreq[str] = 1;
    } else {
        tFreq[str] += 1;
    }
    winFreq[str] = ;
}
```

```js
// 滑动窗口核心代码
while (right < s.length) {
    const str = s[right]; // 当前遍历的字符串
    if (tFreq[str] === 0) {
        // 此次遍历的字符串无效，遍历下一位
        right++;
    } else {
        // tFreq[str]存在
        if (winFreq[str] < tFreq[str]) {
            // 有效遍历
            distance++;
        }
        winFreq[str]++;
        right++;

        // 如果滑动窗口满足条件，求出最小路径
        while (distance === t.lenght) {
            if (right - left < minLen) {
                minLen = right - left;
                begin = left;
            }
            if (winFreq[s[left]] === 0) {
                // s[left]为非有效字符串
                left++;
            } else {
                if (winFreq[s[left]] === tFreq[s[left]]) {
                    // 左侧字符为有效字符串
                    distance--;
                }
                left++;
                winFreq[s[left]]--;
            }
        }
    }
}
```

```js
// 获取结果
var minWindow = function (s, t) {
    // ...
    if (minLen > s.length) {
        return "";
    } else {
        return s.slice(begin, begin + minLen);
    }
};
```

#### 二、回溯

###### 1.组合

> 返回范围 [1, n] 中所有可能的 k 个数的组合

1. 定义 1 个结果数组 res 为[]
2. 定义 1 个递归函数 dfs

```js
const dfs = (begin, path) => {
    if (path.length === k) {
        // 满足条件，push进res，return
        res.push(path.slice());
        return;
    }
    for (var i = begin; i <= n; i++) {
        path.push(i);
        dfs(i + 1, path);
        path.pop(); // 回溯
    }
};
```

3. `dfs`从 1 开始执行,返回 res

```js
const combine = (n, k) => {
    const res = [];
    const dfs = () => {};
    dfs(1, []);
    return res;
};
```

###### 2.子集

> 整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

1. 回溯算法，包含该数 或者 不包含该数

```js
const subsets = function (nums) {
    const result = [];
    const path = [];
    const backtrack = (begin) => {
        result.push(path.slice());
        for (var i = begin; i < nums.length; i++) {
            path.push(nums[i]);
            backtrack(i + 1);
            path.pop();
        }
    };

    backtrack(0);
    return result;
};
```

###### 3.单词搜索

> 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

1. 定义好框架

```js
const exsit = function (board, word) {
    const h = board.length;
    const w = board[0].length;
    // 矩阵中字符串，4个方向的坐标
    const directions = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0],
    ];
    const visited = new Array(h); // 有多少行
    for (let i = 0; i < h; i++) {
        // 初始化该位置是否访问过
        visited[i] = new Array(w).fill(false);
    }

    const check = () => {};

    for (let i = 0; i < h; i++) {
        for (let j = 0; j < w; j++) {
            const flag = check(i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }

    return false;
};
```

2. 判断该坐标是否是正确路径

```js
const check = (i, j, s, k) => {
    if (s[i][j] !== s[k]) {
        // 字符匹配不上，非正确路径
        return false;
    } else if ((k = s.length - 1)) {
        // 匹配上了，并且k为s的最后1个字符
        return true;
    } else {
        // 匹配上了，非最后1个字符
        visited[i][j] = true;
        let result = false;
        for (const [dx, dy] of directions) {
            const newi = i + dx; // 新的i坐标
            const newj = j + dy; // 新的j坐标
            if (newi >= 0 && newi < h && newj > 0 && newj < w) {
                const flag = check(newi, newj, s, k + 1);
                if (flag) {
                    return true;
                }
            }
        }

        visited[i][j] = false; // 回溯
        return false;
    }
};
```
