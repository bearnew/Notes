- [一、滑动窗口](#一滑动窗口)
    - [1. 最小覆盖字串](#1-最小覆盖字串)
- [二、回溯](#二回溯)
    - [1.组合](#1组合)
    - [2.子集](#2子集)
    - [3.单词搜索](#3单词搜索)
- [三、快慢指针](#三快慢指针)
    - [1. 删除有序数组中的重复项 II](#1-删除有序数组中的重复项-ii)
- [四、链表循环](#四链表循环)
    - [1. 删除排序链表中的重复项](#1-删除排序链表中的重复项)
- [五、二分法](#五二分法)
    - [1. 搜索旋转排序数组 II](#1-搜索旋转排序数组-ii)
- [六、单调栈](#六单调栈)
    - [1.柱状图中最大矩形](#1柱状图中最大矩形)

#### 一、滑动窗口

###### 1. 最小覆盖字串

> 返回 s 中涵盖 t 所有字符的最小子串

1. 滑动窗口，left 和 right
2. tFreq 存储字符 s 存在的次数，winFreq 存储窗口给内字符 s 存在的次数
3. distance 存储包含到的字符的个数
4. begin 从哪里开始
5. winFreq 中字符 s 数量小于 tFreq 中字符 s 数量，包含字符串的长度 distance++
6. distance 等于 t.length，证明包含完全
7. 替换 minLen
8. 左侧不包含子串，缩短左侧
9. 左侧包含字串，缩短左侧，distance--

```js
// 定义各种变量
const tFreq = {}; // t中每个字符串包含的次数
const winFreq = {}; // 滑动窗口中包含t中每个字符串的次数
let left = 0; // 滑动窗口左
let right = 0; // 滑动窗口右
let distance = 0; // 有效路径
let minLen = s.length + 1; // 最长
var begin = 0;
```

```js
// 遍历t存储tFreq和winFreq
for (let i = 0; i < t.length; i++) {
    const str = t[i];
    if (!tFreq[str]) {
        tFreq[str] = 1;
    } else {
        tFreq[str] += 1;
    }
    winFreq[str] = ;
}
```

```js
// 滑动窗口核心代码
while (right < s.length) {
    const str = s[right]; // 当前遍历的字符串
    if (tFreq[str] === 0) {
        // 此次遍历的字符串无效，遍历下一位
        right++;
    } else {
        // tFreq[str]存在
        if (winFreq[str] < tFreq[str]) {
            // 有效遍历
            distance++;
        }
        winFreq[str]++;
        right++;

        // 如果滑动窗口满足条件，求出最小路径
        while (distance === t.lenght) {
            if (right - left < minLen) {
                minLen = right - left;
                begin = left;
            }
            if (winFreq[s[left]] === 0) {
                // s[left]为非有效字符串
                left++;
            } else {
                if (winFreq[s[left]] === tFreq[s[left]]) {
                    // 左侧字符为有效字符串
                    distance--;
                }
                left++;
                winFreq[s[left]]--;
            }
        }
    }
}
```

```js
// 获取结果
var minWindow = function (s, t) {
    // ...
    if (minLen > s.length) {
        return "";
    } else {
        return s.slice(begin, begin + minLen);
    }
};
```

#### 二、回溯

###### 1.组合

> 返回范围 [1, n] 中所有可能的 k 个数的组合

1. 定义 1 个结果数组 res 为[]
2. 定义 1 个递归函数 dfs

```js
const dfs = (begin, path) => {
    if (path.length === k) {
        // 满足条件，push进res，return
        res.push(path.slice());
        return;
    }
    for (var i = begin; i <= n; i++) {
        path.push(i);
        dfs(i + 1, path);
        path.pop(); // 回溯
    }
};
```

3. `dfs`从 1 开始执行,返回 res

```js
const combine = (n, k) => {
    const res = [];
    const dfs = () => {};
    dfs(1, []);
    return res;
};
```

###### 2.子集

> 整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

1. 回溯算法，包含该数 或者 不包含该数

```js
const subsets = function (nums) {
    const result = [];
    const path = [];
    const backtrack = (begin) => {
        result.push(path.slice());
        for (var i = begin; i < nums.length; i++) {
            path.push(nums[i]);
            backtrack(i + 1);
            path.pop();
        }
    };

    backtrack(0);
    return result;
};
```

###### 3.单词搜索

> 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

1. 定义好框架

```js
const exsit = function (board, word) {
    const h = board.length;
    const w = board[0].length;
    // 矩阵中字符串，4个方向的坐标
    const directions = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0],
    ];
    const visited = new Array(h); // 有多少行
    for (let i = 0; i < h; i++) {
        // 初始化该位置是否访问过
        visited[i] = new Array(w).fill(false);
    }

    const check = () => {};

    for (let i = 0; i < h; i++) {
        for (let j = 0; j < w; j++) {
            const flag = check(i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }

    return false;
};
```

2. 判断该坐标是否是正确路径

```js
const check = (i, j, s, k) => {
    if (s[i][j] !== s[k]) {
        // 字符匹配不上，非正确路径
        return false;
    } else if ((k = s.length - 1)) {
        // 匹配上了，并且k为s的最后1个字符
        return true;
    } else {
        // 匹配上了，非最后1个字符
        visited[i][j] = true;
        let result = false;
        for (const [dx, dy] of directions) {
            const newi = i + dx; // 新的i坐标
            const newj = j + dy; // 新的j坐标
            if (newi >= 0 && newi < h && newj > 0 && newj < w) {
                const flag = check(newi, newj, s, k + 1);
                if (flag) {
                    return true;
                }
            }
        }

        visited[i][j] = false; // 回溯
        return false;
    }
};
```

#### 三、快慢指针

###### 1. 删除有序数组中的重复项 II

> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

1. 基本框架

```js
var removeDuplicates = function (nums) {
    const len = nums.length;
    const maxDuplicateLen = 2;
    if (len < maxDuplicateLen) {
        return len;
    }

    let slow = maxDuplicateLen - 1; // 从index 1 开始
    let fast = maxDuplicateLen; // 从index 2开始

    while (fast < len) {
        if (nums[slow - (maxDuplicateLen - 1)] === nums[fast]) {
            // slow前1个值和fast值相同，则证明重复数值多了
            fast++;
        } else {
            // slow前1个值和fast值不同，
            // 值保留slow前一个值和slow当前值，将slow+1到fast的值截断
            nums[slow + 1] = nums[fast];
            // 截断之后，继续遍历
            slow++;
            fast++;
        }
    }

    return slow + 1;
};
```

#### 四、链表循环

###### 1. 删除排序链表中的重复项

> 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。

1. 链表循环，遇到和下一个值和当前值相同，直接删除下一个值

```js
var deleteDuplicates = function (head) {
    if (!head) return head;
    var curr = head;
    while (curr.next) {
        if (curr.val === curr.next.val) {
            // 当前值和下个值相等，移除下个值
            curr.next = curr.next.next;
        } else {
            // 当前值和下个值不等，移除下个值
            curr = curr.next;
        }
    }

    return head;
};
```

#### 五、二分法

###### 1. 搜索旋转排序数组 II

1. 定义 left 和 right，判断 mid 是否和 target 相等
2. left 的值等于 mid 的值，无法判断前半段还是后半段有序，left++
3. left 小于 mid，说明前半部分有序，在前半部分进行二分法
4. mid 小于 right，说明后半部分有序，在后半部分进行二分法

```js
var search = function (nums, target) {
    if (nums.length === 0) return false;
    if (nums.length === 1) return nums[0] === target;

    var left = 0;
    var right = nums.length - 1;
    while (left <= right) {
        var mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) {
            return true;
        } else if (nums[left] === nums[mid]) {
            // 无法区分前半部分还是后半部分有序
            left++;
        } else if (nums[left] < nums[mid]) {
            // 前半部分有序
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid - 1;
            }
        } else if (nums[mid] <= nums[right]) {
            // 后半部分有序
            if (target <= nums[right] && target > nums[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return false;
};
```

#### 六、单调栈

###### 1.柱状图中最大矩形

1. 维护一个 stack 栈。遍历 heights 数组的每一个 bar
2. 当前 bar 比栈顶的 bar 高，直接入栈
3. 当前 bar 比栈顶的 bar 矮：
    1. 栈顶元素（索引）出栈，暂存给 stackTopIndex 变量
    2. 计算以 heights[stackTopIndex] 为高的长方形的面积，宽度 = 当前 bar 的索引 i - 新的栈顶索引 - 1 ，与全局的最大比较
    3. 当前 bar 继续和新的栈顶比较，重复上面过程，直到当前 bar 不再比栈顶的 bar 矮，入栈

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {
    let maxArea = 0;
    const stack = [];
    const newHeights = heights.slice(0);
    // 需要遍历length+1位
    newHeights.push(0);

    for (let i = 0, len = newHeights.length; i <= len; i++) {
        while (
            stack.length > 0 &&
            newHeights[i] < newHeights[stack[stack.length - 1]]
        ) {
            // 当前最高点元素的高
            let height = newHeights[stack.pop()];
            // stack不为空，pop后的stack最后1位到pop元素的值都比当前元素大，需要左侧+右侧宽度
            // stack为空，stack栈底一直为最小值, pop的值为数组当前遍历的最小值
            let width = stack.length > 0 ? i - stack[stack.length - 1] - 1 : i;
            maxArea = Math.max(maxArea, width * height);
        }
        stack.push(i);
    }

    return maxArea;
};
```
