# 前端调试通关秘籍

## 1.调试网页 JS

1. `Chrome DevTools` 和 `VSCode Debugger` 都是使用`CDP`(`Chrome DevTools Protocol`)调试网页
   - ![20230214005118-2023-02-14](https://raw.githubusercontent.com/bearnew/picture/master/picGo/20230214005118-2023-02-14.png)
2. ws 服务调试
   - ![20230214010050-2023-02-14](https://raw.githubusercontent.com/bearnew/picture/master/picGo/20230214010050-2023-02-14.png)

## 2.VSCode Chrome Debugger 配置

- launch：调试模式启动浏览器，访问某个 url，然后连上进行调试
- attach：连接某个已经在调试模式启动的 url 进行调试
- userDataDir： user data dir 是保存用户数据的地方，比如浏览历史、cookie 等，一个数据目录只能跑一个 chrome，所以默认会创建临时用户数据目录，想用默认的目录可以把这个配置设为 false
- runtimeExecutable：切换调试用的浏览器，可以是 stable、canary 或者自定义的
- runtimeArgs：启动浏览器的时候传递的启动参数
- sourceMapPathOverrides：对 sourcemap 到的文件路径做一次映射，映射到 VSCode workspace 下的文件，这样调试的文件就可以修改了
- file：可以直接指定某个文件，然后启动调试

```js
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "pwa-chrome",
            "request": "launch",
            "name": "Launch Chrome against localhost",
            "runtimeArgs": [
               "--auto-open-devtools-for-tabs", // 自动打开开发工具台
               "--incognito" // 隐私模式
            ],
            "file": "${workspaceFolder}/test.html",
            "webRoot": "${workspaceFolder}"
        }
    ]
}
```

## 3.source map

1. `sourcemap`的格式

```js
// version：sourcemap 的版本，一般为 3
// file：编译后的文件名
// sourceRoot：源码根目录
// names：转换前的变量名
// sources：源码文件名
// sourcesContent：每个 sources 对应的源码的内容
// mappings：一个个位置映射
{
　　　　version : 3,
　　　　file: "out.js",
　　　　sourceRoot : "",
　　　　sources: ["foo.js", "bar.js"],
　　　　names: ["a", "b"],
　　　　mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
      sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```

2. `@sentry/webpack-plugin`

- 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉
- 还提供了 @sentry/cli 让用户可以手动上传。

3. 通过 astexplorer.net 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。
4. [source-map](https://www.npmjs.com/package/source-map)
   - 创建一个 SourceMapGenerator 对象
   - 通过 addMapping 方法添加一个映射
   - 通过 toString 转为 sourcemap 字符串
5. `eval`
   - `eval` 代码的最后加上 `//# sourceURL=xxx`就可以打断点了
   - `sourcemap` 的生成还是很慢的，要一个个 `mapping` 的处理，做编码之类的
   - `eval` 这个特性来优化的 `sourcemap` 生成的性能
   - `webpack` 利用这个特性来简化了 `sourcemap` 的处理，可以直接从模块开始映射，不用从 `bundle` 级别。
6. 配置
   - `^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`
   - `cheap`，不需要映射到源码的行和列
     - 只映射到源代码的某一行，不精确到列，可以提升 `sourcemap` 生成速度
   - `module`
     - 多个`loader`转换，默认 `sourcemap` 只是能从 `bundle`关联到模块的代码，也就是只关联了最后那个 `sourcemap`。
     - `module`能够一次性映射回最初的源码
   - `nosources`
     - 不生成`sourceContent`，文件大小会小很多
   - `source-map`
     - 可以配置 `inline`，会以 `dataURL` 的方式内联
     - 可以配置 `hidden`，只生成 `sourcemap`
7. `SourceMapDevToolPlugin`简化配置的填写
   - 相当于是 `devtool` 的另一种配置方式，启用它需要把 `devtool` 设置为 `false`。

## 4.Debugger 断点映射

1. `webpack` 项目的时候要配置 `sourceMapPathOverrides`
   ```js
   {
      "sourceMapPathOverrides": {
         "webpack://vue-demo/src/*": "${workspaceFolder}/src/*"
      }
   }
   ```
   ```js
   {
      "sourceMapPathOverrides": {
         "webpack:///src/*": "${workspaceFolder}/src/*"
      }
   }
   ```

## 5.调试 node_modules 源码

1. `build`出带`source map`的包
2. 使用`source-map-loader`映射源码

```js
{
   test: /node_modules/,
   loader: 'source-map-loader'
}
```

## 6.snippets 生成器

> https://snippet-generator.app/

## 7.node.js 调试

- node.js 源码

```js
const fs = require("fs/promises");

(async function () {
  const fileContent = await fs.readFile("./package.json", {
    encoding: "utf-8",
  });

  await fs.writeFile("./package2.json", fileContent);
})();
```

- 调试配置

```js
// launch.json
{
   "configurations": [
      {
         "name": "Launch Program",
         "program": "${workspaceFolder}/server.js",
         "request": "launch",
         "skipFiles": [
               "<node_internals>/**"
         ],
         "stopOnEntry": true,
         "type": "node"
      },
   ]
}
```

## 8.npm script 调试

```js
{
    "configurations": [
    {
        "name": "Launch via NPM",
        "request": "launch",
        "runtimeArgs": [
            "run-script",
            "start"
        ],
        "runtimeExecutable": "npm",
        "skipFiles": [
            "<node_internals>/**"
        ],
        "type": "node"
    }
    ]
}
```

## 9.JS 调试的 9 种作用域

- `Global` 作用域： 全局作用域，在浏览器环境下就是 `window`，在 `node` 环境下是 `global`
- `Local` 作用域：本地作用域，或者叫函数作用域
- `Block` 作用域：块级作用域
- `Script` 作用域：`let`、`const` 声明的全局变量会保存在 `Script` 作用域，这些变量可以直接访问，但却不能通过 `window.xx`访问
- 模块作用域：其实严格来说这也是函数作用域，因为`node`执行它的时候会包一层函数，算是比较特殊的函数作用域，有 `module`、`exports`、`require` 等变量
- `Catch Block` 作用域： `catch`语句的作用域可以访问错误对象
- `With Block` 作用域：`with` 语句会把传入的对象的值放到单独的作用域里，这样 `with` 语句里就可以直接访问了
- `Closure` 作用域：函数返回函数的时候，会把用到的外部变量保存在 `Closure` 作用域里，这样再执行的时候该有的变量都有，这就是闭包。`eval` 的闭包比较特殊，会把所有变量都保存到 `Closure` 作用域
- `Eval` 作用域：`eval` 代码声明的变量会保存在 `Eval` 作用域

## 10.github 项目下载

- `--depth=1` 是下载单 `commit`，提升速度
- `--single-branch` 是下载单个分支，提升速度

```js
git clone --depth=1 --single-branch https://github.com/nestjs/nest
```

## 11.Eslint 调试

1. `Eslint`有命令行和`api`2 种入口
2. `ESLint` 是通过 `AST` 实现的检查，具体检查是 `rule` 里做的，`fix` 的实现就是字符串替换，但因为多个 `rule` 的 `fix` 可能冲突，所以会循环来做，但最多循环 10 次

```js
{
    "name": "eslint 调试",
    "program": "${workspaceFolder}/node_modules/.bin/eslint",
    "args": [
        "./index.js",
        "--fix"
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
    "cwd": "${workspaceFolder}",
    "request": "launch",
    "type": "node"
}
```

## 12.patch-package

1. `patches` 文件的生成是在临时目录生成 `package.json`，下载依赖，生成一个 `commit`，然后把改动的代码复制过去，两者做 `gif diff`，就可以生成 `patches` 文件。
2. `patches` 文件的应用则是 `patch-package` 自己实现了它的 `parse`，拿到对什么文件的哪些行做什么修改的信息，之后根据不同做类型做不同的文件操作就可以了。
3. 如果是 `pnpm`，那 `patch-package` 不支持，这时候用内置的 `pnpm patch` 命令就好了。

## 13.babel

1. `parse`：把源码转成 `AST`
2. `traverse`：对 `AST` 做遍历，遍历过程中做增删改
3. `generate`：生成目标代码和 `sourcemap`

```js
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generate = require("@babel/generator").default;

const source = `
    (async function() {
        console.log('hello guangguang');
    })();
`;

const ast = parser.parse(source);

traverse(ast, {
  StringLiteral(path) {
    path.node.value = path.node.value.replace("guangguang", "dongdong");
  },
});

const { code, map } = generate(ast, {
  sourceMaps: true,
});

console.log(code);
console.log(JSON.stringify(map));
```

```js
// 调试node babel_test.js的配置
{
   "name": "Launch Program",
   "program": "${workspaceFolder}/babel_test.js",
   "request": "launch",
   "resolveSourceMapLocations": [
         "${workspaceFolder}/**",
   ],
   "skipFiles": [
         "<node_internals>/**"
   ],
   "type": "node"
},
```
