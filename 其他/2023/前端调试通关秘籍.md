# 前端调试通关秘籍

## 1.调试网页 JS

1. `Chrome DevTools` 和 `VSCode Debugger` 都是使用`CDP`(`Chrome DevTools Protocol`)调试网页
   - ![20230214005118-2023-02-14](https://raw.githubusercontent.com/bearnew/picture/master/picGo/20230214005118-2023-02-14.png)
2. ws 服务调试
   - ![20230214010050-2023-02-14](https://raw.githubusercontent.com/bearnew/picture/master/picGo/20230214010050-2023-02-14.png)

## 2.VSCode Chrome Debugger 配置

- launch：调试模式启动浏览器，访问某个 url，然后连上进行调试
- attach：连接某个已经在调试模式启动的 url 进行调试
- userDataDir： user data dir 是保存用户数据的地方，比如浏览历史、cookie 等，一个数据目录只能跑一个 chrome，所以默认会创建临时用户数据目录，想用默认的目录可以把这个配置设为 false
- runtimeExecutable：切换调试用的浏览器，可以是 stable、canary 或者自定义的
- runtimeArgs：启动浏览器的时候传递的启动参数
- sourceMapPathOverrides：对 sourcemap 到的文件路径做一次映射，映射到 VSCode workspace 下的文件，这样调试的文件就可以修改了
- file：可以直接指定某个文件，然后启动调试

```js
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "pwa-chrome",
            "request": "launch",
            "name": "Launch Chrome against localhost",
            "runtimeArgs": [
               "--auto-open-devtools-for-tabs", // 自动打开开发工具台
               "--incognito" // 隐私模式
            ],
            "file": "${workspaceFolder}/test.html",
            "webRoot": "${workspaceFolder}"
        }
    ]
}
```

## 3.source map

1. `sourcemap`的格式

```js
// version：sourcemap 的版本，一般为 3
// file：编译后的文件名
// sourceRoot：源码根目录
// names：转换前的变量名
// sources：源码文件名
// sourcesContent：每个 sources 对应的源码的内容
// mappings：一个个位置映射
{
　　　　version : 3,
　　　　file: "out.js",
　　　　sourceRoot : "",
　　　　sources: ["foo.js", "bar.js"],
　　　　names: ["a", "b"],
　　　　mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
      sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```

2. `@sentry/webpack-plugin`

- 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉
- 还提供了 @sentry/cli 让用户可以手动上传。

3. 通过 astexplorer.net 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。
4. [source-map](https://www.npmjs.com/package/source-map)
   - 创建一个 SourceMapGenerator 对象
   - 通过 addMapping 方法添加一个映射
   - 通过 toString 转为 sourcemap 字符串
5. `eval`
   - `eval` 代码的最后加上 `//# sourceURL=xxx`就可以打断点了
   - `sourcemap` 的生成还是很慢的，要一个个 `mapping` 的处理，做编码之类的
   - `eval` 这个特性来优化的 `sourcemap` 生成的性能
   - `webpack` 利用这个特性来简化了 `sourcemap` 的处理，可以直接从模块开始映射，不用从 `bundle` 级别。
6. 配置
   - `^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`
   - `cheap`，不需要映射到源码的行和列
     - 只映射到源代码的某一行，不精确到列，可以提升 `sourcemap` 生成速度
   - `module`
     - 多个`loader`转换，默认 `sourcemap` 只是能从 `bundle`关联到模块的代码，也就是只关联了最后那个 `sourcemap`。
     - `module`能够一次性映射回最初的源码
   - `nosources`
     - 不生成`sourceContent`，文件大小会小很多
   - `source-map`
     - 可以配置 `inline`，会以 `dataURL` 的方式内联
     - 可以配置 `hidden`，只生成 `sourcemap`
7. `SourceMapDevToolPlugin`简化配置的填写
   - 相当于是 `devtool` 的另一种配置方式，启用它需要把 `devtool` 设置为 `false`。

## 4.Debugger 断点映射

1. `webpack` 项目的时候要配置 `sourceMapPathOverrides`
   ```js
   {
      "sourceMapPathOverrides": {
         "webpack://vue-demo/src/*": "${workspaceFolder}/src/*"
      }
   }
   ```
   ```js
   {
      "sourceMapPathOverrides": {
         "webpack:///src/*": "${workspaceFolder}/src/*"
      }
   }
   ```

## 5.调试 node_modules 源码

1. `build`出带`source map`的包
2. 使用`source-map-loader`映射源码

```js
{
   test: /node_modules/,
   loader: 'source-map-loader'
}
```

## 6.snippets 生成器

> https://snippet-generator.app/

## 7.node.js 调试

- node.js 源码

```js
const fs = require("fs/promises");

(async function () {
  const fileContent = await fs.readFile("./package.json", {
    encoding: "utf-8",
  });

  await fs.writeFile("./package2.json", fileContent);
})();
```

- 调试配置

```js
// launch.json
{
   "configurations": [
      {
         "name": "Launch Program",
         "program": "${workspaceFolder}/server.js",
         "request": "launch",
         "skipFiles": [
               "<node_internals>/**"
         ],
         "stopOnEntry": true,
         "type": "node"
      },
   ]
}
```

## 8.npm script 调试

```js
{
    "configurations": [
    {
        "name": "Launch via NPM",
        "request": "launch",
        "runtimeArgs": [
            "run-script",
            "start"
        ],
        "runtimeExecutable": "npm",
        "skipFiles": [
            "<node_internals>/**"
        ],
        "type": "node"
    }
    ]
}
```
