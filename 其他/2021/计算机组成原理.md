# 计算机组成原理

## 1.计算机组成

- 计算机应用程序（应用软件）
- 操作系统、编译原理、计算机网络
- 计算机体系结构（系统软件）
- 计算机组成
- `CPU/GPU`、内存/硬盘、显示器/键盘（硬件）

## 2.计算机三大件

1. `CPU`(`Central Processing Unit`)
   - CPU 是计算机最昂贵的部分
   - CPU 是一个超级精细的印刷电路板
2. 内存（`Memory`）
   - 撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行
   - 程序读取的数据、计算得到的结果，也都要放在内存里
   - 内存越大，能加载的东西自然也就越多。
   - 内存通常直接可以插在主板上
   - 存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。
3. 主板（`Motherboard`）
   - `CPU` 要插在主板上，内存也要插在主板上
   - 主板的芯片组（`Chipset`）和总线（`Bus`）解决了 `CPU` 和内存之间如何通信的问题
   - 芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题
   - 总线则是实际数据传输的高速公路
   - 总线速度（Bus Speed）决定了数据能传输得多快
4. 其他
   - `I/O`设备，显示器、鼠标、键盘，`I/O`设备通过主板上的南桥芯片来和`CPU`通信
   - 硬盘将数据持久存储下来
   - 显卡，显卡里存在`GPU`（`Graphics Processing Unit，图形处理器`）
   - 网吧没有硬盘，通过局域网读写远程网络硬盘里面的数据
   - 云服务通过`ssh`远程登陆，没必要配显示器、鼠标、键盘
5. 计算机祖师爷之一冯·诺依曼（John von Neumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机。

## 3.计算机组成原理

1. 计算机硬件组成部分
   - 运算器、控制器、存储器、输入设备和输出设备
2. 计算器 2 个核心指标
   - 性能和功耗
3. 计算机的指令和计算
   - 程序通过编译器和汇编器，变成机器指令
   - 指令的执行是由控制器控制
   - 运算器，算术逻辑单元

## 4.CPU 主频

1. 性能
   - 响应时间：执行程序需要花费的时间
   - 吞吐率：时间范围内能处理多少事情，如网络带宽，计算器 8 核，16 核
2. CPU 主频
   - `2.8GHz`表示 `CPU` 在 1s 时间内，可以执行的简单指令数量是 `2.8G` 条
3. CPU 的执行时间
   - 程序的 `CPU` 执行时间=`CPU` 时钟周期数 x 时钟周期时间
   - `CPU` 时钟周期时间：1/2.8G
   - `CPU` 时钟周期数：指令数 x 每条指令的平均时钟周期数（`Cycles Per Instruction`简称`CPI`）
   - 加法和乘法都对应着一条 `CPU` 指令，但是乘法需要的 `Cycles` 就比加法要多，自然也就慢
4. 超频
   - 将 `CPU` 内部的钟调快，执行更快，散热压力更大

## 5.功耗

1. CPU（超大规模集成电路）
   - 这些电路实际是由晶体管组合而成的，CPU 计算时，其实就是让晶体管里面的开关不断地打开和关闭，来组合完成各种运算和功能
2. 计算更快
   - 多放一些晶体管，增加密度
   - 让晶体管打开和关闭更快，提升主频
3. 以上 2 点，都会增加功耗，带来耗电和散热问题
4. 在 CPU 上抹硅脂、装风扇、以及用上水冷来散热
5. 功耗：功耗 ~= 1/2 × 负载电容 × 电压的平方 × 开关频率 × 晶体管数量
6. 通过并行提升性能：2 核、4 核、8 核
7. 优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 将多个计算结果汇总的时间

## 6.计算机指令：让我们试试用纸带编程

1. `CPU` 就是一个执行各种计算机指令（`Instruction Code`）的逻辑机器
2. 上世纪 60、70 年代，将穿孔卡交给计算机执行
3. 程序执行过程

   1. 编译（Compile）成汇编代码。
   2. 针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）
   3. 这一条条机器码，就是一条条的计算机指令。
   4. 这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。
   5. 汇编码是 add、mov 这些用英文表示的指令
   6. 机器码是 8b 45 f8 的 16 进制数字

4. 指令
   1. 算术类指令：我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。
   2. 数据传输类指令: 给变量赋值、在内存里读写数据，用的都是数据传输类指令。
   3. 逻辑类指令: 逻辑上的与或非，都是这一类指令。
   4. 条件分支类指令: 日常我们写的“if/else”，其实都是条件分支类指令。
   5. 无条件跳转指令: 写一些大一点的程序，我们常常需要写一些函数或者方法。
5. 指令表格
   |指令类型|示例指令|示例汇编代码|含义|注释|
   |:----|:-----|:-----|:----|:-----|
   |算术类指令|add|add$s1,$s2,$s3|$s1=$s2+$s3|将 s2 和 s3 寄存器中的数相加后的结果放到寄存器 s1 中|
   |逻辑类指令|or|or$s1,$s2,$s3|$s1=$s2|$s3|将 s2 和 s3 寄存器中的数按位取或的结果放到寄存器 s1 中|
   |数据传输指令|load work|load $s1,10($s2)|$s1=memory[$s2+10]|取 s2 寄存器中的数，加上 10 的偏移量后，找到内存中的字，存入到 s1 寄存器中|
   |条件分支指令|branch on equal|beq $s1,$s2,10|if($s1==$s2)go to PC+4+10|如果 s1 和 s2 寄存器内的值相等，从程序计数器往后跳 10|
   |无条件跳转指令|jump|j 1000|go to 1000|跳转到 1000 这个目标地址|

## 7.指令跳转：原来 if...else 就是 goto

1. 我们在单条指令的基础上，学习了程序里的多条指令，究竟是怎么样一条一条被执
   行的。除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行
   指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指
   令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。
2. 我们可以用高级语言，可以用不同的语法，比如 if…else 这样的条件分支，
   或者 while/for 这样的循环方式，来实现不用的程序运行流程，但是回归到计算机可以识别
   的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。
3. 在硬件层面实现这个 goto 语句，除了本身需要用来保存下一条指令地址，以及当前正
   要执行指令的 PC 寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条
   件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功
   能。
4. 三大寄存器
   - PC 寄存器: 指令地址寄存器，用来存放下一条需要执行的计算机指令的内存地址。
   - 指令寄存器：用来存放当前正在执行的指令。
   - 条件码寄存器：用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

## 8.函数调用：为什么会发生 stack overflow？

1. CPU 指令层面是在程序栈中执行函数调用的
2. 压栈和出栈使程序在不同的函数调用中进行转移
3. 函数内联进行优化
4. 循环调用会导致栈溢出
5. 程序栈相当于一个记忆功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。
   函数能使我们复用代码和指令

## 9.ELF 和静态链接：为什么程序无法同时在 Linux 和 Windows 下运行？

1. windows 和 linux 可执行文件的格式不一样
2. Linux 只能执行`ELF`文件，使用开源项目`Wine`可以兼容`PE`文件
3. Windows 只能执行`PE`文件，使用`Windows Subsystem for Linux`可以解析和加载`ELF`格式文件

## 10.程序装载：“640K 内存”真的不够用么？

1. 程序装载面临的挑战
   1. 可执行程序加载后占用的内存空间应该是连续的
   2. 我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置
      - 虚拟内存地址: 指令里用到的内存地址
      - 物理内存地址: 实际在内存硬件里面的空间地址
   3. 我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。
   4. 因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。
2. 内存碎片问题
   - 启用程序后再关掉，会导致这个程序占用的内存不连续
   - 使用内存交换处理
3. 内存分页
   - 和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小
   - 而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。
   - 页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。
   - CPU 只需要执行当前的指令，极限情况下，内存也只需要加载一页就好了。再大的程序，也可以分成一页。
   - 硬盘的访问速度比内存慢很多

## 11. 动态链接：程序内部的“共享单车”

1. 在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的共享库（Shared Libraries）。
2. 在 Windows 下，这些共享库文件就是.dll（Dynamic-Link Libary） 文件
3. 在 Linux 下，这些共享库文件就是.so （Shared Object）文件
4. 在进行 Linux 下的程序开发的时候，我们一直会用到各种各样的动态链接库。C 语言的标准库就在 1MB 以上。我们撰写任何一个程序可能都需要用到这个库，常见的 Linux 服务器里，/usr/bin 下面就有上千个可执行文件

## 12.二进制编码：“手持两把锟斤拷，口中疾呼烫烫烫”？

1. 原码表示法
   - 把一个数最左侧的一位，当成是对应的正负号，比如 0 为正数，1 为负数
   - 一个 4 位的二进制数， 0011 就表示为 +3。 1011 表示-3
2. ASCII 码（American Standard Code for Information Interchange，美国信息交换标准代码）。
   - 用 8 位二进制中的 128 个不同的数，映射到 128 个不同的字符里。
   - 小写字母 a 在 ASCII 里面，就是第 97 个，也就是二进制的 0110 0001，对应的十六进制表示就是 61
   - 而大写字母 A，就是第 65 个，也就是二进制的 0100 0001，对应的十六进制表示就是 41。
3. 不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。
4. 字符集，表示的可以是字符的一个集合。比如“中文”就是一个字符集
5. 日常说的 Unicode，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。
6. 字符编码则是对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典
7. Unicode，就可以用 UTF-8、UTF-16，乃至 UTF-32 来进行编码，存储成二进制
8. “我”对应的 UTF-8 的编码是 6211，也可以自己发明一套编码方式 GT-32,存储为 1126
9. 同样的文本，需采用和存储一致的编码方式进行解码，不然会乱码

## 13 | 理解电路：从电报机到门电路，我们如何做到“千里传信”？

1. 电报传输的信号有两种，一种是短促的点信号（dot 信号），一种是长一点的划信号（dash 信号）
2. 我们把“点”当成“1”，把“划”当成“0”。
3. 电影里最常见的电报信号是“SOS”，这个信号表示出来就是 “点点点划划划点点点”。
4. 电报本质上是通过电信号来进行传播的，所以从输入信号到输出信号基本上没有延时
5. 电报机本质上就是一个“蜂鸣器 + 长长的电线 + 按钮开关”
6. 为了能够实现这样接力传输信号，在电路里面，工程师们造了一个叫作继电器（Relay）的设备。
7. 继电器通电之后，产生磁力，下一级的中继开关被打开，传递信号再到下一个中继
8. 光缆，随着距离的增长、反射次数的增加，信号也会有所衰减，我们同样要每隔一段距离，来增加一个用来重新放大信号的中继。
