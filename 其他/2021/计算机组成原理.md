# 计算机组成原理

## 1.计算机组成

- 计算机应用程序（应用软件）
- 操作系统、编译原理、计算机网络
- 计算机体系结构（系统软件）
- 计算机组成
- `CPU/GPU`、内存/硬盘、显示器/键盘（硬件）

## 2.计算机三大件

1. `CPU`(`Central Processing Unit`)
   - CPU 是计算机最昂贵的部分
   - CPU 是一个超级精细的印刷电路板
2. 内存（`Memory`）
   - 撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行
   - 程序读取的数据、计算得到的结果，也都要放在内存里
   - 内存越大，能加载的东西自然也就越多。
   - 内存通常直接可以插在主板上
   - 存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。
3. 主板（`Motherboard`）
   - `CPU` 要插在主板上，内存也要插在主板上
   - 主板的芯片组（`Chipset`）和总线（`Bus`）解决了 `CPU` 和内存之间如何通信的问题
   - 芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题
   - 总线则是实际数据传输的高速公路
   - 总线速度（Bus Speed）决定了数据能传输得多快
4. 其他
   - `I/O`设备，显示器、鼠标、键盘，`I/O`设备通过主板上的南桥芯片来和`CPU`通信
   - 硬盘将数据持久存储下来
   - 显卡，显卡里存在`GPU`（`Graphics Processing Unit，图形处理器`）
   - 网吧没有硬盘，通过局域网读写远程网络硬盘里面的数据
   - 云服务通过`ssh`远程登陆，没必要配显示器、鼠标、键盘
5. 计算机祖师爷之一冯·诺依曼（John von Neumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机。

## 3.计算机组成原理

1. 计算机硬件组成部分
   - 运算器、控制器、存储器、输入设备和输出设备
2. 计算器 2 个核心指标
   - 性能和功耗
3. 计算机的指令和计算
   - 程序通过编译器和汇编器，变成机器指令
   - 指令的执行是由控制器控制
   - 运算器，算术逻辑单元

## 4.CPU 主频

1. 性能
   - 响应时间：执行程序需要花费的时间
   - 吞吐率：时间范围内能处理多少事情，如网络带宽，计算器 8 核，16 核
2. CPU 主频
   - `2.8GHz`表示 `CPU` 在 1s 时间内，可以执行的简单指令数量是 `2.8G` 条
3. CPU 的执行时间
   - 程序的 `CPU` 执行时间=`CPU` 时钟周期数 x 时钟周期时间
   - `CPU` 时钟周期时间：1/2.8G
   - `CPU` 时钟周期数：指令数 x 每条指令的平均时钟周期数（`Cycles Per Instruction`简称`CPI`）
   - 加法和乘法都对应着一条 `CPU` 指令，但是乘法需要的 `Cycles` 就比加法要多，自然也就慢
4. 超频
   - 将 `CPU` 内部的钟调快，执行更快，散热压力更大

## 5.功耗

1. CPU（超大规模集成电路）
   - 这些电路实际是由晶体管组合而成的，CPU 计算时，其实就是让晶体管里面的开关不断地打开和关闭，来组合完成各种运算和功能
2. 计算更快
   - 多放一些晶体管，增加密度
   - 让晶体管打开和关闭更快，提升主频
3. 以上 2 点，都会增加功耗，带来耗电和散热问题
4. 在 CPU 上抹硅脂、装风扇、以及用上水冷来散热
5. 功耗：功耗 ~= 1/2 × 负载电容 × 电压的平方 × 开关频率 × 晶体管数量
6. 通过并行提升性能：2 核、4 核、8 核
7. 优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 将多个计算结果汇总的时间

## 6.计算机指令：让我们试试用纸带编程

1. `CPU` 就是一个执行各种计算机指令（`Instruction Code`）的逻辑机器
2. 上世纪 60、70 年代，将穿孔卡交给计算机执行
3. 程序执行过程

   1. 编译（Compile）成汇编代码。
   2. 针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）
   3. 这一条条机器码，就是一条条的计算机指令。
   4. 这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。
   5. 汇编码是 add、mov 这些用英文表示的指令
   6. 机器码是 8b 45 f8 的 16 进制数字

4. 指令
   1. 算术类指令：我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。
   2. 数据传输类指令: 给变量赋值、在内存里读写数据，用的都是数据传输类指令。
   3. 逻辑类指令: 逻辑上的与或非，都是这一类指令。
   4. 条件分支类指令: 日常我们写的“if/else”，其实都是条件分支类指令。
   5. 无条件跳转指令: 写一些大一点的程序，我们常常需要写一些函数或者方法。
5. 指令表格
   |指令类型|示例指令|示例汇编代码|含义|注释|
   |:----|:-----|:-----|:----|:-----|
   |算术类指令|add|add$s1,$s2,$s3|$s1=$s2+$s3|将 s2 和 s3 寄存器中的数相加后的结果放到寄存器 s1 中|
   |逻辑类指令|or|or$s1,$s2,$s3|$s1=$s2|$s3|将 s2 和 s3 寄存器中的数按位取或的结果放到寄存器 s1 中|
   |数据传输指令|load work|load $s1,10($s2)|$s1=memory[$s2+10]|取 s2 寄存器中的数，加上 10 的偏移量后，找到内存中的字，存入到 s1 寄存器中|
   |条件分支指令|branch on equal|beq $s1,$s2,10|if($s1==$s2)go to PC+4+10|如果 s1 和 s2 寄存器内的值相等，从程序计数器往后跳 10|
   |无条件跳转指令|jump|j 1000|go to 1000|跳转到 1000 这个目标地址|

## 7.指令跳转：原来 if...else 就是 goto

1. 我们在单条指令的基础上，学习了程序里的多条指令，究竟是怎么样一条一条被执
   行的。除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行
   指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指
   令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。
2. 我们可以用高级语言，可以用不同的语法，比如 if…else 这样的条件分支，
   或者 while/for 这样的循环方式，来实现不用的程序运行流程，但是回归到计算机可以识别
   的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。
3. 在硬件层面实现这个 goto 语句，除了本身需要用来保存下一条指令地址，以及当前正
   要执行指令的 PC 寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条
   件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功
   能。
4. 三大寄存器
   - PC 寄存器: 指令地址寄存器，用来存放下一条需要执行的计算机指令的内存地址。
   - 指令寄存器：用来存放当前正在执行的指令。
   - 条件码寄存器：用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。
5.
