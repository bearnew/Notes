# 全链路性能优化

## 1.图片优化

1. `JPEG(Joint Photographic Experts Group)`
   - 联合图像专家小组是一种针对色彩照片而广泛使用的有损压缩图形格式
   - 介绍：栅格图形，常用文件扩展名为`.jpg`，也有`.jpeg`、`.jpe`。`JPEG`在互联网上常被应用于存储和传输照片
   - 不适合：线条图形和文字、图标图形，因为它的压缩算法不适合这些类型的图形，并且不支持透明度
   - 非常适合：颜色丰富的图片、彩色图、大焦点图、通栏 banner 图，结构不规则的图形
2. `PNG(Portable Network Graphics)`
   - 便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性
   - 介绍：栅格图形。`PNG`最初是作为替代`GIF`设计的，能够显示 256 色，文件比`JPEG`或者`GIF`大，但是`PNG`非常好的保留了图片质量。支持`Alpha`通道的半透明和透明特性。最高支持 24 位彩色图像（PNG-24）和 8 位灰色图像（PNG-8）
   - 不适合：由于是无损存储，彩色图像体积太大
   - 非常适合：纯色、透明、线条绘图、图标；边缘清晰、有大块相同颜色区域；颜色数较少但需要半透明。
3. `GIF(Graphics Interchange Format)`
   - 图像互换格式是一种位图图形文件格式，以 8 位色（即 256 种颜色）重现真彩色的图像，采用`LZW`压缩算法进行编码
   - 介绍: 栅格图形。支持 256 色；仅支持完全透明和完全不透明；如果需要比较通用的动画，GIF 是唯一选择
   - 不适合：每个像素只有 8 比特，不适合存储彩色图片
   - 非常适合：动画、图标
4. `Webp`
   - `Webp`是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活，由`Google`在购买`On2 Technologies`后发展出来，以`BSD`授权条款发布
   - 介绍：优秀算法能同时保证一定程度上的图像质量和比较小的体积；可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。无损的`webp`比`PNG`小 26%，有损的`webp`比`jpeg`小`25-34%`，比 GIF 有更好的动画
   - 不适合：最多处理 256 色，不适合于彩色图片
   - 非常适合：适用于图形和半透明图形
5. `Svg`
   - SVG 意为可缩放矢量图形（`Scalable Vector Graphics`）。
   - 它使用 XML 格式定义图像。非光栅格式，区别于光栅格式的依靠像素点来存储图像，矢量图是通过 XML 格式来数据化的记录图像的信息
   - SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。
   - SVG 是万维网联盟的标准。
   - SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体。
   - SVG 的优势
     - SVG 可被非常多的工具读取和修改（比如记事本）。
     - 完全支持 DOM，以及 JavaScript 能够很好的访问到它。
     - SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。
     - SVG 是可伸缩的
     - SVG 图像可在任何的分辨率下被高质量地打印。
     - SVG 可在图像质量不下降的情况下被放大。
     - SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）。
     - SVG 是开放的标准。
     - SVG 文件是纯粹的 XML。
6. `iconfont`
   - 优点
     - 减少请求次数，将多个 icon 合并到一个字体文件中，从而提高网页性能；
     - 自由的变化大小和颜色，因为字体是可以通过样式来设置大小和颜色的；
     - 矢量图不失真；
     - 适合多平台（浏览器、iOS App、Android App）；
     - svg 支持多色图标，不受单色的限制
     - 可以通过`font-size`和`color`来调整样式
     - 减少 HTTP 请求
     - 可以精细的控制`SVG`图标的每一部分
   - 缺点
     - 单色
     - 维护成本高

## 2.图优化

1. 用工具进行图片压缩
   - 压缩 png: `node-pngquant-native`(跨平台，压缩比例高，要锁 png24 非常好)
   - 压缩 jpg: `jpegtran`（跨平台，有 `Linux`、`Mac`、`Windows` 解决方案）
   - 压缩 gif: `Gifsicle`(通过改变每帧比例，减少 gif 文件大小，同时可以使用透明来达到更小的文件大小，目前公认的方案)
2. 图片尺寸随网络环境变化
   - 不同网络环境(Wifi/4G/3G)下，加载不同尺寸和像素的图片，通过在图片 URL 后缀加不同参数改变
   - 全局图片用通用的方法包裹实现
3. 响应式图片
   - `javascript`绑定事件检测窗口大小
   - CSS 媒体查询
     ```css
     @media screen and(max-width: 640px) {
       .my_image {
         width: 640px;
       }
     }
     ```
   - img 标签属性
     ```html
     <!-- x描述符：表示图像的设备像素比 -->
     <!-- srcset根据不同的像素比展示不同图片 -->
     <!-- 不支持srcset则使用src展示 -->
     <img
       srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x"
       src="img-960w.jpg"
       alt="img"
     />
     ```
4. 逐步加载图像
   - 使用统一占位符
   - 使用`LQIP`
     - 低质量图像占位符(`Low Quality Image Placeholders`)
     - 安装: `npm install lqip`
   - 使用`SQIP`
     - 基于`SVG`的图像占位符(`SVG Quality Image Placeholders`)
     - 安装: `npm install sqip`
5. 真的需要图片吗
   - `Web Font`代替图片
   - `Data URI`(base64)代替图片
   - 采用`Image Spriting`(雪碧图)

## 3.图片服务器自动优化解密

1. 图片服务器自动化优化是可以在图片 URL 链接上增加不同特殊参数，服务器自动化生成不同格式、大小、质量的图片
2. 处理方式
   - 图片裁剪：按长边、短边、填充、拉伸等缩放
   - 图片格式转换：支持 JPG，GIF，PNG，Webp 等，支持不同的图片压缩率
   - 图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框
   - AI 能力：鉴黄以及智能抠图、智能排版、只能配色、智能合成等 AI 功能

## 4.精简优化 HTML 代码结构

1. 减少 HTML 的嵌套
2. 减少 DOM 节点数
3. 减少无语义的代码（比如: <div class="clear"></div>清除浮动）
4. 删除`http`或者`https`，如果 URL 的协议头和当前页面的协议头一致的，或者此 URL 在多个协议头都是可用的，则可以考虑删除协议头
5. 删除多余的空格、换行符、缩进和不必要的注释
6. 省略冗余标签和属性
7. 使用相对路径的 URL
8. 文件放在合适的位置
   - css 样式文件链接尽量放在页面的头部
     - CSS 加载不会阻塞`DOM tree`解析，但是会阻塞`DOM tree`渲染，也会阻塞后面`JS`执行。任何`body`元素之前，可以确保在文档部分中解析了所有的`CSS`样式(内联和外联)，从而减少了浏览器必须重排文档的次数。如果放置页面底部，就要等待最后一个`CSS`文件下载完成，此时会出现”白屏“，影响用户体验
   - JS 引用放在 HTML 底部
     - 防止 js 的加载、解析、执行对阻塞页面后续元素的正常渲染
9. 设置 favicon.icon
   - 网站如果不设置`favicon.ico`，控制台会报错，另外页面加载过程中也没有图标`loading`过程，同时也不利于记忆网站品牌，建议统一添加
10. 增加首屏必要的 CSS 和 JS

    - 页面如果需要等待所有的 js、css 加载完成才显示，则在渲染过程中页面会一致显示空白，影响用户体验，建议增加首屏必要的 css 和 js，比如页面框架背景图或者`loading`图标，内联在 HTML 页面中。这样做，首屏能快速显示出来，相对减少用户对页面加载等待过程

## 5.CSS 的优化

1. 提升 CSS 的渲染性能
   1. 谨慎使用`expensive`属性：`nth-child`伪类；`position:fixed`定位
   2. 尽量减少样式层级数
      ```css
      div ul li span i {
        color: red;
      }
      ```
   3. 尽量避免使用占用过多 CPU 和内存的属性
      - `text-indent: -99999px`
   4. 尽量避免使用耗电量大的属性
      - css3 3D tranforms, css3 transitions, Opacity
2. 合适使用 CSS 选择器
   1. 尽量避免使用 CSS 表达式
      - `background-color: expression((new Date()).getHours()%2 ? '#fff' : '#0000')`
   2. 尽量避免使用通配选择器
      - `body > a { font-weight: bold }`
   3. 尽量避免类正则的属性选择器
      - `*=, |=, ^=, $=`
3. 提升 `CSS` 的文件加载性能
   - 使用外链的 `CSS`
   - 尽量避免使用`@import`

## 6.如何提升 js 的执行效率

1. js 文件的加载
   - 加载元素的顺序 CSS 文件放在<head>里，Js 文件放在<body>里
2. js 变量和函数优化
   - 尽量使用`id`选择器
   - 尽量避免使用`eval`
   - `js`函数尽可能保持简洁
   - 使用事件节流函数
   - 使用事件委托
3. js 动画优化
   - 避免添加大量 js 动画
   - 尽量使用 CSS3 动画
   - 尽量使用`Canvas`动画
   - 合理使用`requestAnimationFrame`动画代替`setTimeout`,`setInterval`
     - `requestAnimationFrame`可以在正确的时间进行渲染，`setTimeout(callback)`和`setInterval(callback)`无法保证`callback`回调函数的执行时机
4. 合理使用缓存
   - 合理缓存 `DOM` 对象
   - 缓存列表长度
   - 使用可缓存的`Ajax`

## 7.如何对 js 的缓存进行优化

1. Cookie
   - 通常由浏览器存储，然后将 cookie 与每个后续请求一起发送到同一服务器。收到 HTTP 请求时，服务器可以发送带有 Cookie 的`header`头。可以给`Cookie`设置有效时间
   - 应用于
     - 会话管理：登录名、购物车商品、游戏得分或服务器应要记录的其他任何内容
     - 个性化：用户首选项，主题或其他设置
     - 跟踪：记录和分析用户行为，比如埋点
2. sessionStorage
   - 创建一个本地存储的键/值对
   - 应用于：
     - 页面应用页面之间的传值
3. IndexedDB
   - 索引数据库
   - 应用于：
     - 客户端存储大量结构化数据
     - 没有网络连接的情况下使用（如 Google Doc、石墨文档）
     - 将冗余、很少修改、但经常访问的数据，以避免随时从服务器获取数据
4. LocalStorage
   - 本地存储
   - 应用于：
     - 缓存静态文件内容 js/css（如百度 M 站首页，用文件的内容做 md5 值，值变更才更新）
     - 缓存不常变更的 API 接口数据
     - 存储地理位置信息
     - 浏览在页面的具体位置

## 8.如何选择合适的模块化加载方案

1. commonJS
   - 旨在 `web` 浏览器之外为 `js` 建立模块生态系统
   - `Node.js`模块化方案`Commonjs`
   - eg
   ```js
   var store = require("store");
   ```
   ```js
   exports = function () {
     return store.get("customers");
   };
   ```
2. AMD（Asynchronous Module Definition）(异步模块定义)规范
   - RequireJS 模块化加载器：基于 AMD API 实现
   - eg
   ```js
   // math.js
   define(function () {
     var add = function (x, y) {
       return x + y;
     };
     return { add };
   });
   ```
   ```js
   // main.js
   require(["math"], function (math) {
     alert(math.add(1, 1));
   });
   ```
3. CMD（Common Module Definition）（通用模块定义）规范
   - SeaJS 模块化加载器：遵循 CMD API 编写
   - eg
   ```js
   define("module", ["module1", "module2"], function (
     require,
     exports,
     module
   ) {
     // 模块代码
   });
   ```
4. ES6 import

## 9.怎样减少浏览器的回流和重绘

1. CSS
   - 避免过多的样式嵌套
   - 避免使用 CSS 表达式（每次 CSS 绘制时都会执行）
   - 使用绝对定位，可以让动画元素脱离文档流
   - 避免使用`table`布局（引起浏览器多次重绘）
   - 尽量不适用`float`布局（引起浏览器多次重绘）
   - 图片最好设置好`width`和`height`
   - 尽量简化浏览器不必要的任务，减少页面重新布局
   - 使用`Viewport`设置屏幕缩放级别
   - 避免频繁设置样式，最好把`style`属性设置完成后，进行一次性更改
   - 避免使用引起回流、重绘的属性，最好把相应变量缓存起来
2. JS
   - 最小化回流和重排
     - 为了减少回流发生次数，避免频繁或操作 DOM，可以合并多次对 DOM 修改，然后一次性批量处理
   - 控制绘制过程和绘制区域
     - 绘制过程开销比较大的属性设置应该尽量避免减少使用
     - 减少绘制区域范围
3.
